<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="keywords" content="dom.js,DOM,JavaScript,Toolkit"><meta name="description" content="dom.js - 专门处理 DOM 操作的 JavaScript 工具库。"><link rel="shortcut icon" href="./favicon.ico"><title>dom.js | 专门处理 DOM 操作的 JavaScript 工具库</title><link rel="preload" href="css/docs.min.css" as="style"><link rel="preload" href="js/docs.min.js" as="script"><link href="css/docs.min.css" rel="stylesheet" type="text/css"></head><body><div class="docs" id="docs"><aside class="aside" id="aside"><header class="aside__header"><h2 class="aside__h2">API Documentation</h2></header></aside><main class="main" id="main"><header class="main__header" id="header"><h1 class="main__h1"><strong class="main__name">dom.</strong>js</h1><p class="main__tagline">dom.js - 专门处理 DOM 操作的 JavaScript 工具库。</p></header><div class="main__cdn" id="cdn"><pre class="main__pre"><code>&lt;script src="https://cdn.jsdelivr.net/gh/yaohaixiao/dom.js/dom.min.js"&gt;&lt;/script&gt;</code></pre></div><div class="main__download" id="download"><a class="main__button" href="https://github.com/yaohaixiao/dom.js/archive/refs/heads/main.zip" target="_blank">Download Zip</a></div><article id="article"><section class="section"><header class="section__header"><h2 class="section__title">Attributes</h2></header><div class="section__content"><p>dom.js 提供以下方法来获取和设置元素的 DOM 属性。</p></div><section class="section"><header class="section__header"><h3 class="section__h3">hasClass(el, className)</h3></header><div class="section__content"><p>hasClass() 方法用来判断 DOM 元素是否包含指定 className 的样式。</p><dl class="section__dl"><dt class="section__dt">Category：</dt><dd class="section__dd">Attributes</dd></dl><h4 class="section__h4">Parameters</h4><h5 class="section__h4">el</h5><dl class="section__dl"><dt class="section__dt">Type：</dt><dd class="section__dd">HTMLElement</dd></dl><p>（必须）el 参数指定需要检测 class 样式的 DOM 元素。</p><h5 class="section__h4">className</h5><dl class="section__dl"><dt class="section__dt">Type：</dt><dd class="section__dd">String</dd></dl><p>（必须）className 要添加的 class 样式名称。</p><h4 class="section__h4">Usage</h4><pre class="section__pre"><code class="section__code">&lt;ul id="list" class="list"&gt;
    &lt;li class="item active"&gt;Home&lt;/li&gt;
    &lt;li class="item"&gt;Blog&lt;/li&gt;
    &lt;li class="item"&gt;Projects&lt;/li&gt;
    &lt;li class="item"&gt;About&lt;/li&gt;
&lt;/ul&gt;

// 引入 DOM 模块（中的所有工具方法）
import DOM from '@yaohaixiao/dom.js/dom
// 引用 addClass 单个方法
import hasClass from '@yaohaixiao/dom.js/addClass'

const $list = DOM.byId('#list')

// 添加 class 样式
DOM.addClass($list, 'nav')
DOM.addClass($list, 'primary')

// 判断是否存在 class 样式
DOM.hasClass($list, 'nav') => true
hasClass($list, 'primary') => true
hasClass($list, 'top-menu') => false</code></pre></div></section><section class="section"><header class="section__header"><h3 class="section__h3">addClass(el, className)</h3></header><div class="section__content"><p>addClass() 方法用来给 DOM 元素添加 class 样式。</p><dl class="section__dl"><dt class="section__dt">Category：</dt><dd class="section__dd">Attributes</dd></dl><h4 class="section__h4">Parameters</h4><h5 class="section__h4">el</h5><dl class="section__dl"><dt class="section__dt">Type：</dt><dd class="section__dd">HTMLElement</dd></dl><p>（必须）el 参数指定需要添加 class 样式的 DOM 元素。</p><h5 class="section__h4">className</h5><dl class="section__dl"><dt class="section__dt">Type：</dt><dd class="section__dd">String</dd></dl><p>（必须）className 参数指定要检测的 class 样式名称。</p><h5 class="section__h4">Returns</h5><dl class="section__dl"><dt class="section__dt">Type：</dt><dd class="section__dd">Boolean</dd></dl><p>如果 el 元素包含 className 的 class 样式，则返回 true，否则返回 false。</p><h4 class="section__h4">Usage</h4><pre class="section__pre"><code class="section__code">&lt;ul id="list" class="list"&gt;
    &lt;li class="item active"&gt;Home&lt;/li&gt;
    &lt;li class="item"&gt;Blog&lt;/li&gt;
    &lt;li class="item"&gt;Projects&lt;/li&gt;
    &lt;li class="item"&gt;About&lt;/li&gt;
&lt;/ul&gt;

// 引入 DOM 模块（中的所有工具方法）
import DOM from '@yaohaixiao/dom.js/dom
// 引用 addClass 单个方法
import hasClass from '@yaohaixiao/dom.js/addClass'

const $list = DOM.byId('#list')

// 添加 class 样式
DOM.addClass($list, 'nav')
DOM.addClass($list, 'primary')

// 判断是否存在 class 样式
DOM.hasClass($list, 'nav') => true
hasClass($list, 'primary') => true
hasClass($list, 'top-menu') => false</code></pre></div></section><section class="section"><header class="section__header"><h3 class="section__h3">replaceClass(el, oldCls, newCls)</h3></header><div class="section__content"><p>replaceClass() 方法用来替换 DOM 元素中的 className 的样式。</p><dl class="section__dl"><dt class="section__dt">Category：</dt><dd class="section__dd">Attributes</dd></dl><h4 class="section__h4">Parameters</h4><h5 class="section__h4">el</h5><dl class="section__dl"><dt class="section__dt">Type：</dt><dd class="section__dd">HTMLElement</dd></dl><p>（必须）el 参数指定需要替换 class 样式的 DOM 元素。</p><h5 class="section__h4">className</h5><dl class="section__dl"><dt class="section__dt">Type：</dt><dd class="section__dd">String</dd></dl><p>（必须）oldCls 要替换的 class 样式名称。</p><h5 class="section__h4">className</h5><dl class="section__dl"><dt class="section__dt">Type：</dt><dd class="section__dd">String</dd></dl><p>（必须）newCls 用来替换的 class 样式名称。</p><h4 class="section__h4">Usage</h4><pre class="section__pre"><code class="section__code">&lt;ul id="list" class="list"&gt;
    &lt;li class="item active"&gt;Home&lt;/li&gt;
    &lt;li class="item"&gt;Blog&lt;/li&gt;
    &lt;li class="item"&gt;Projects&lt;/li&gt;
    &lt;li class="item"&gt;About&lt;/li&gt;
&lt;/ul&gt;

// 引入 DOM 模块（中的所有工具方法）
import DOM from '@yaohaixiao/dom.js/dom
// 引用 addClass 单个方法
import replaceClass from '@yaohaixiao/dom.js/removeClass'

const $list = DOM.byId('#list')

// 添加 class 样式
DOM.addClass($list, 'nav')

// 判断是否存在 class 样式
DOM.replaceClass($list, 'nav', 'main')

hasClass($list, 'list') => true
hasClass($list, 'nav') => false
hasClass($list, 'main') => true</code></pre></div></section><section class="section"><header class="section__header"><h3 class="section__h3">removeClass(el, className)</h3></header><div class="section__content"><p>removeClass() 方法用来移除 DOM 元素中的 className 的样式。</p><dl class="section__dl"><dt class="section__dt">Category：</dt><dd class="section__dd">Attributes</dd></dl><h4 class="section__h4">Parameters</h4><h5 class="section__h4">el</h5><dl class="section__dl"><dt class="section__dt">Type：</dt><dd class="section__dd">HTMLElement</dd></dl><p>（必须）el 参数指定需要移除 class 样式的 DOM 元素。</p><h5 class="section__h4">className</h5><dl class="section__dl"><dt class="section__dt">Type：</dt><dd class="section__dd">String</dd></dl><p>（必须）className 参数指定要移除的 class 样式名称。</p><h4 class="section__h4">Usage</h4><pre class="section__pre"><code class="section__code">&lt;ul id="list" class="list"&gt;
    &lt;li class="item active"&gt;Home&lt;/li&gt;
    &lt;li class="item"&gt;Blog&lt;/li&gt;
    &lt;li class="item"&gt;Projects&lt;/li&gt;
    &lt;li class="item"&gt;About&lt;/li&gt;
&lt;/ul&gt;

// 引入 DOM 模块（中的所有工具方法）
import DOM from '@yaohaixiao/dom.js/dom
// 引用 addClass 单个方法
import removeClass from '@yaohaixiao/dom.js/removeClass'

const $list = DOM.byId('#list')

// 添加 class 样式
DOM.addClass($list, 'nav')
DOM.addClass($list, 'primary')

// 判断是否存在 class 样式
DOM.removeClass($list, 'nav') => true
removeClass($list, 'primary')

hasClass($list, 'list') => true
hasClass($list, 'nav') => false
hasClass($list, 'primary') => false</code></pre></div></section><section class="section"><header class="section__header"><h3 class="section__h3">toggleClass(el, className)</h3></header><div class="section__content"><p>toggleClass() 方法用来切换（添加或删除） DOM 元素中的 className 的样式。</p><dl class="section__dl"><dt class="section__dt">Category：</dt><dd class="section__dd">Attributes</dd></dl><h4 class="section__h4">Parameters</h4><h5 class="section__h4">el</h5><dl class="section__dl"><dt class="section__dt">Type：</dt><dd class="section__dd">HTMLElement</dd></dl><p>（必须）el 参数指定需要切换 class 样式的 DOM 元素。</p><h5 class="section__h4">className</h5><dl class="section__dl"><dt class="section__dt">Type：</dt><dd class="section__dd">String</dd></dl><p>（必须）className 参数指定要切换的样式名称。</p><h4 class="section__h4">Usage</h4><pre class="section__pre"><code class="section__code">&lt;ul id="list" class="list"&gt;
    &lt;li class="item active"&gt;Home&lt;/li&gt;
    &lt;li class="item"&gt;Blog&lt;/li&gt;
    &lt;li class="item"&gt;Projects&lt;/li&gt;
    &lt;li class="item"&gt;About&lt;/li&gt;
&lt;/ul&gt;

// 引入 DOM 模块（中的所有工具方法）
import DOM from '@yaohaixiao/dom.js/dom
// 引用 addClass 单个方法
import hasClass from '@yaohaixiao/dom.js/addClass'
import toggleClass from '@yaohaixiao/dom.js/toggleClass'

const $active = document.querySelector('.active')

// 添加 class 样式
hasClass($active, 'active') // -> true

// 判断是否存在 class 样式
DOM.toggleClass($active, 'active')
hasClass($active, 'active') // -> false

// 判断是否存在 class 样式
toggleClass($active, 'active')
hasClass($active, 'active') // -> true</code></pre></div></section><section class="section"><header class="section__header"><h3 class="section__h3">getAttribute(el, attr)</h3></header><div class="section__content"><p>getAttribute() 方法用来获取 DOM 元素的 DOM 属性值。</p><dl class="section__dl"><dt class="section__dt">Category：</dt><dd class="section__dd">Attributes</dd></dl><h4 class="section__h4">Parameters</h4><h5 class="section__h4">el</h5><dl class="section__dl"><dt class="section__dt">Type：</dt><dd class="section__dd">HTMLElement</dd></dl><p>（必须）el 参数指定 DOM 元素。</p><h5 class="section__h4">className</h5><dl class="section__dl"><dt class="section__dt">Type：</dt><dd class="section__dd">String</dd></dl><p>（必须）attr 参数指定要获取的属性名称。</p><h5 class="section__h4">Returns</h5><dl class="section__dl"><dt class="section__dt">Type：</dt><dd class="section__dd">Any</dd></dl><p>返回指定的属性值。</p><h4 class="section__h4">Usage</h4><pre class="section__pre"><code class="section__code">&lt;ul id="list" class="list"&gt;
    &lt;li class="item active"&gt;Home&lt;/li&gt;
    &lt;li class="item"&gt;Blog&lt;/li&gt;
    &lt;li class="item"&gt;Projects&lt;/li&gt;
    &lt;li class="item"&gt;About&lt;/li&gt;
&lt;/ul&gt;

// 引入 DOM 模块（中的所有工具方法）
import DOM from '@yaohaixiao/dom.js/dom
// 引用 getAttribute 单个方法
import getAttribute from '@yaohaixiao/dom.js/getAttribute'

const $list = byId('#list')

getAttribute($list, 'id') // -> 'list'
// 针对 className 属性获取样式属性
DOM.getAttribute($list, 'className') // -> 'list'

DOM.addClass($list, 'nav')
// 也可以直接实用 class 属性，因为在获取属性时，class 不存在 JS 的保留关键字的限制
DOM.getAttribute($list, 'class') // -> 'list nav'</code></pre></div></section><section class="section"><header class="section__header"><h3 class="section__h3">getAttributes(el, props)</h3></header><div class="section__content"><p>getAttribute() 方法用来获取 DOM 元素的多个 DOM 属性值。</p><dl class="section__dl"><dt class="section__dt">Category：</dt><dd class="section__dd">Attributes</dd></dl><h4 class="section__h4">Parameters</h4><h5 class="section__h4">el</h5><dl class="section__dl"><dt class="section__dt">Type：</dt><dd class="section__dd">HTMLElement</dd></dl><p>（必须）el 参数指定 DOM 元素。</p><h5 class="section__h4">className</h5><dl class="section__dl"><dt class="section__dt">Type：</dt><dd class="section__dd">Array</dd></dl><p>（可选）props 参数指定要获取的属性名称的数组，不指定则获取全部 DOM 属性。</p><h5 class="section__h4">Returns</h5><dl class="section__dl"><dt class="section__dt">Type：</dt><dd class="section__dd">Any</dd></dl><p>返回查询的多属性的键/值对象。</p><h4 class="section__h4">Usage</h4><pre class="section__pre"><code class="section__code">&lt;ul id="list" class="list"&gt;
    &lt;li class="item active"&gt;Home&lt;/li&gt;
    &lt;li class="item"&gt;Blog&lt;/li&gt;
    &lt;li class="item"&gt;Projects&lt;/li&gt;
    &lt;li class="item"&gt;About&lt;/li&gt;
&lt;/ul&gt;

// 引入 DOM 模块（中的所有工具方法）
import DOM from '@yaohaixiao/dom.js/dom
// 引用 getAttributes 单个方法
import getAttributes from '@yaohaixiao/dom.js/getAttributes'

const $list = byId('#list')

DOM.getAttributes($list, ['id', 'class']) // -> { id: 'list', class: 'list' }
getAttributes($list) // -> { id: 'list', class: 'list' }
getAttributes($list, ['className']) // -> { className: 'list' }</code></pre></div></section><section class="section"><header class="section__header"><h3 class="section__h3">setAttribute(el, attr, value)</h3></header><div class="section__content"><p>getAttribute() 方法用来设置 DOM 元素的 DOM 属性值。</p><dl class="section__dl"><dt class="section__dt">Category：</dt><dd class="section__dd">Attributes</dd></dl><h4 class="section__h4">Parameters</h4><h5 class="section__h4">el</h5><dl class="section__dl"><dt class="section__dt">Type：</dt><dd class="section__dd">HTMLElement</dd></dl><p>（必须）el 参数指定 DOM 元素。</p><h5 class="section__h4">attr</h5><dl class="section__dl"><dt class="section__dt">Type：</dt><dd class="section__dd">String</dd></dl><p>（必须）attr 参数指定属性名称。</p><h5 class="section__h4">value</h5><dl class="section__dl"><dt class="section__dt">Type：</dt><dd class="section__dd">Any</dd></dl><p>（必须）value 参数指定属性值。</p><h4 class="section__h4">Usage</h4><pre class="section__pre"><code class="section__code">&lt;ul id="list" class="list"&gt;
    &lt;li class="item active"&gt;Home&lt;/li&gt;
    &lt;li class="item"&gt;Blog&lt;/li&gt;
    &lt;li class="item"&gt;Projects&lt;/li&gt;
    &lt;li class="item"&gt;About&lt;/li&gt;
&lt;/ul&gt;

// 引入 DOM 模块（中的所有工具方法）
import DOM from '@yaohaixiao/dom.js/dom
// 引用 setAttribute 单个方法
import setAttribute from '@yaohaixiao/dom.js/setAttribute'

const $list = byId('#list')

DOM.setAttribute($list, 'data-id', 'list')
DOM.getAttribute($list, 'data-id') // -> 'list'

// 可以一次性调整多个样式，性能更好
setAttribute($list, 'style', 'width:200px;height:30px;')
DOM.getAttribute($list, 'style') // -> 'width:200px;height:30px;'

DOM.setAttribute($list, 'className', 'nav')
DOM.getAttribute($list, 'className') // -> 'nav'</code></pre></div></section><section class="section"><header class="section__header"><h3 class="section__h3">setAttributes(el, attrs)</h3></header><div class="section__content"><p>getAttributes() 方法用来给 DOM 元素一次设置多个 DOM 属性/值。</p><dl class="section__dl"><dt class="section__dt">Category：</dt><dd class="section__dd">Attributes</dd></dl><h4 class="section__h4">Parameters</h4><h5 class="section__h4">el</h5><dl class="section__dl"><dt class="section__dt">Type：</dt><dd class="section__dd">HTMLElement</dd></dl><p>（必须）el 参数指定 DOM 元素。</p><h5 class="section__h4">attrs</h5><dl class="section__dl"><dt class="section__dt">Type：</dt><dd class="section__dd">Object</dd></dl><p>（必须）attrs 参数指定要设置的属性键/值对象。</p><h4 class="section__h4">Usage</h4><pre class="section__pre"><code class="section__code">&lt;ul id="list" class="list"&gt;
    &lt;li class="item active"&gt;Home&lt;/li&gt;
    &lt;li class="item"&gt;Blog&lt;/li&gt;
    &lt;li class="item"&gt;Projects&lt;/li&gt;
    &lt;li class="item"&gt;About&lt;/li&gt;
&lt;/ul&gt;

// 引入 DOM 模块（中的所有工具方法）
import DOM from '@yaohaixiao/dom.js/dom
// 引用 setAttributes 单个方法
import setAttributes from '@yaohaixiao/dom.js/setAttributes'

const $list = byId('#list')

setAttributes($list, {
  'aria-hidden': true,
  'data-id': 'list',
  style: 'height:30px;width:100%;'
})

DOM.getAttribute($list, 'data-id') // -> 'list'</code></pre></div></section><section class="section"><header class="section__header"><h3 class="section__h3">removeAttribute(el, attr)</h3></header><div class="section__content"><p>removeAttribute() 方法用来移除 DOM 元素的 DOM 属性值。</p><dl class="section__dl"><dt class="section__dt">Category：</dt><dd class="section__dd">Attributes</dd></dl><h4 class="section__h4">Parameters</h4><h5 class="section__h4">el</h5><dl class="section__dl"><dt class="section__dt">Type：</dt><dd class="section__dd">HTMLElement</dd></dl><p>（必须）el 参数指定 DOM 元素。</p><h5 class="section__h4">attr</h5><dl class="section__dl"><dt class="section__dt">Type：</dt><dd class="section__dd">String</dd></dl><p>（必须）attr 参数指定属性名称。</p><h4 class="section__h4">Usage</h4><pre class="section__pre"><code class="section__code">&lt;ul id="list" class="list"&gt;
    &lt;li class="item active"&gt;Home&lt;/li&gt;
    &lt;li class="item"&gt;Blog&lt;/li&gt;
    &lt;li class="item"&gt;Projects&lt;/li&gt;
    &lt;li class="item"&gt;About&lt;/li&gt;
&lt;/ul&gt;

// 引入 DOM 模块（中的所有工具方法）
import DOM from '@yaohaixiao/dom.js/dom
// 引用 removeAttribute 单个方法
import removeAttribute from '@yaohaixiao/dom.js/removeAttribute'

const $list = byId('#list')

DOM.removeAttribute($list, 'id')
DOM.getAttribute($list, 'id') // -> null

// 可以一次性调整多个样式，性能更好
DOM.setAttribute($list, 'style', 'width:200px;height:30px;')
DOM.getAttribute($list, 'style') // -> 'width:200px;height:30px;'

removeAttribute($list, 'style')
DOM.getAttribute($list, 'style') // -> null</code></pre></div></section><section class="section"><header class="section__header"><h3 class="section__h3">removeAttributes(el, attrs)</h3></header><div class="section__content"><p>removeAttributes() 方法用来移除 DOM 元素（一个或）多个 DOM 属性。不设置 attrs，则移除 el 元素上的所有 DOM 属性。</p><dl class="section__dl"><dt class="section__dt">Category：</dt><dd class="section__dd">Attributes</dd></dl><h4 class="section__h4">Parameters</h4><h5 class="section__h4">el</h5><dl class="section__dl"><dt class="section__dt">Type：</dt><dd class="section__dd">HTMLElement</dd></dl><p>（必须）el 参数指定 DOM 元素。</p><h5 class="section__h4">attrs</h5><dl class="section__dl"><dt class="section__dt">Type：</dt><dd class="section__dd">Object</dd></dl><p>（可选）attrs 参数指定要移除的属性名称数组，不设置 attrs，则移除 el 元素上的所有 DOM 属性。</p><h4 class="section__h4">Usage</h4><pre class="section__pre"><code class="section__code">&lt;ul id="list" class="list"&gt;
    &lt;li class="item active"&gt;Home&lt;/li&gt;
    &lt;li class="item"&gt;Blog&lt;/li&gt;
    &lt;li class="item"&gt;Projects&lt;/li&gt;
    &lt;li class="item"&gt;About&lt;/li&gt;
&lt;/ul&gt;

// 引入 DOM 模块（中的所有工具方法）
import DOM from '@yaohaixiao/dom.js/dom
// 引用 removeAttributes 单个方法
import removeAttributes from '@yaohaixiao/dom.js/removeAttributes'

const $list = byId('#list')

// 效果相同 removeAttributes(el)
DOM.removeAttributes($list, ['id', 'class'])
DOM.getAttribute($list, 'id') // -> null
DOM.getAttribute($list, 'class') // -> null</code></pre></div></section><section class="section"><header class="section__header"><h3 class="section__h3">attrs(el[, attr, value])</h3></header><div class="section__content"><p>attrs() 方法用来设置或者获取 DOM 元素的（一个或多个） DOM 属性值。</p><dl class="section__dl"><dt class="section__dt">Category：</dt><dd class="section__dd">Attributes</dd></dl><h4 class="section__h4">Parameters</h4><h5 class="section__h4">el</h5><dl class="section__dl"><dt class="section__dt">Type：</dt><dd class="section__dd">HTMLElement</dd></dl><p>（必须）el 参数指定 DOM 元素。</p><h5 class="section__h4">attrs</h5><dl class="section__dl"><dt class="section__dt">Type：</dt><dd class="section__dd">String|Array|Object</dd></dl><p>（可选）attrs 参数指定属性名称。</p><h5 class="section__h4">value</h5><dl class="section__dl"><dt class="section__dt">Type：</dt><dd class="section__dd">Any</dd></dl><p>（可选）value 参数指定属性值。</p><p>attrs() 方法的参数配置有以下几种场景：</p><ol><li>仅传递 el 参数：用于获取 el 元素上的所有 DOM 属性；</li><li>传递了 attr 参数<ol><li>attr 参数为 String 类型<ol><li>传递了 value 参数：用于给 el 元素设置（单个） DOM 属性；</li><li>未传递 value 参数：用于获取 el 元素的（单个）DOM 属性值；</li></ol></li><li>未传递 value 参数<ol><li>attr 参数为 Array 类型：用于获取 el 元素的多个 DOM 属性/值；</li><li>attr 参数为 Object 类型：用于给 el 元素设置多个 DOM 属性/值；</li></ol></li></ol></li></ol><h5 class="section__h4">Returns</h5><dl class="section__dl"><dt class="section__dt">Type：</dt><dd class="section__dd">Any</dd></dl><p>返回获取的单个或者多个 DOM 属性。</p><h4 class="section__h4">Usage</h4><pre class="section__pre"><code class="section__code">&lt;ul id="list" class="list"&gt;
   &lt;li class="item active"&gt;Home&lt;/li&gt;
   &lt;li class="item"&gt;Blog&lt;/li&gt;
   &lt;li class="item"&gt;Projects&lt;/li&gt;
   &lt;li class="item"&gt;About&lt;/li&gt;
&lt;/ul&gt;

// 引入 DOM 模块（中的所有工具方法）
import DOM from '@yaohaixiao/dom.js/dom
// 引用 attrs 单个方法
import attrs from '@yaohaixiao/dom.js/attrs'

const $list = byId('#list')

// 获取所有 DOM 属性
DOM.attrs(el) // => {id:'list',class:'list'}
// 获取单个属性
attrs(el, 'id') // => 'list'
// 获取多个属性
attrs(el, ['id', 'class']) // => {id:'list',class:'list'}

// 设置单个属性
attrs(el, 'id', 'nav')
// 设置多个属性
attrs(el, {id:'list',class:'list'})</code></pre></div></section><section class="section"><header class="section__header"><h3 class="section__h3">html(el[, strHTML])</h3></header><div class="section__content"><p>html() 方法用来获取或者设置 DOM 元素的 innerHTML 属性值，或者通过 HTML 字符串，创建 DOM 元素。</p><dl class="section__dl"><dt class="section__dt">Category：</dt><dd class="section__dd">Attributes</dd></dl><h4 class="section__h4">Parameters</h4><h5 class="section__h4">el</h5><dl class="section__dl"><dt class="section__dt">Type：</dt><dd class="section__dd">HTMLElement|String</dd></dl><p>（必须）el 参数指定 DOM 元素或者用来创建 DOM 元素的 HTML 字符串；</p><h5 class="section__h4">strHTML</h5><dl class="section__dl"><dt class="section__dt">Type：</dt><dd class="section__dd">String</dd></dl><p>（可选）strHTML 参数指定设置的 innerHTML 字符串，如果不指定则返回 el 元素的 innerHTML 属性（字符串）。</p><h5 class="section__h4">Returns</h5><dl class="section__dl"><dt class="section__dt">Type：</dt><dd class="section__dd">Any</dd></dl><p>返回创建的 DOM 元素或者 DOM 元素的 innerHTML 属性（字符串）。</p><h4 class="section__h4">Usage</h4><pre class="section__pre"><code class="section__code">&lt;ul id="list" class="list"&gt;
   &lt;li class="item active"&gt;Home&lt;/li&gt;
   &lt;li class="item"&gt;Blog&lt;/li&gt;
   &lt;li class="item"&gt;Projects&lt;/li&gt;
   &lt;li class="item"&gt;About&lt;/li&gt;
&lt;/ul&gt;

// 引入 DOM 模块（中的所有工具方法）
import DOM from '@yaohaixiao/dom.js/dom
// 引用 html 单个方法
import html from '@yaohaixiao/dom.js/html'

const $list = byId('#list')

// 获取 innerHTML 属性（字符串）
DOM.html($list) // -> '&lt;li class="item active"&gt;Home&lt;/li&gt;&lt;li class="item"&gt;Blog&lt;/li&gt;&lt;li class="item"&gt;About&lt;/li&gt;'

// 将 $list 元素的 innerHTML 设置为 '&lt;li class="item"&gt;Blog&lt;/li&gt;'
html($list, '&lt;li class="item"&gt;Blog&lt;/li&gt;')

// 创建一个 li 标签的 DOM 元素
const $item = html('&lt;li class="item"&gt;About&lt;/li&gt;')
// 将创建的 $item 元素添加到 $list 列表
$list.appendChild($item)</code></pre></div></section><section class="section"><header class="section__header"><h3 class="section__h3">text(el[, str])</h3></header><div class="section__content"><p>text() 方法获取或者设置 DOM 元素的 innerText 属性值，或者通过字符串，创建 TextNode 元素。</p><dl class="section__dl"><dt class="section__dt">Category：</dt><dd class="section__dd">Attributes</dd></dl><h4 class="section__h4">Parameters</h4><h5 class="section__h4">el</h5><dl class="section__dl"><dt class="section__dt">Type：</dt><dd class="section__dd">HTMLElement|String</dd></dl><p>（必须）el 参数指定 DOM 元素或者用来创建 TextNode 元素的字符串。</p><h5 class="section__h4">str</h5><dl class="section__dl"><dt class="section__dt">Type：</dt><dd class="section__dd">String</dd></dl><p>（可选）str 参数指定设置的 innerText 字符串，如果不指定则返回 el 元素的 innerText 属性（字符串）。</p><h5 class="section__h4">Returns</h5><dl class="section__dl"><dt class="section__dt">Type：</dt><dd class="section__dd">Any</dd></dl><p>返回创建的 DOM 元素或者 TextNode 元素的 innerText 属性（字符串）。</p><h4 class="section__h4">Usage</h4><pre class="section__pre"><code class="section__code">&lt;ul id="list" class="list"&gt;
   &lt;li id="active" class="item active"&gt;Home&lt;/li&gt;
   &lt;li class="item"&gt;Blog&lt;/li&gt;
   &lt;li class="item"&gt;Projects&lt;/li&gt;
   &lt;li class="item"&gt;About&lt;/li&gt;
&lt;/ul&gt;

// 引入 DOM 模块（中的所有工具方法）
import DOM from '@yaohaixiao/dom.js/dom
// 引用 text 单个方法
import text from '@yaohaixiao/dom.js/text'

const $active = byId('#active')

// 获取 innerText 属性（字符串）
DOM.text($active) // -> 'Home'

// 将 $active 元素的 innerText 设置为 'Homepage'
text($active, 'Homepage')

// 创建一个文本为 URL 的 TextNode 元素
const $text = test('URL')
// 将创建的 $text 元素添加到 $active
$active.appendChild($text)
text($active) // -> 'HomepageURL'</code></pre></div></section></section><section class="section"><header class="section__header"><h2 class="section__title">Base</h2></header><div class="section__content"><p>dom.js 提供以下方法用以创建或查询 DOM 元素等基础 DOM 操作。</p></div><section class="section"><header class="section__header"><h3 class="section__h3">createElement(tagName[, attrs, children])</h3></header><div class="section__content"><h4 class="section__h4">Description</h4><dl class="section__dl"><dt class="section__dt">Type：</dt><dd class="section__dd">Function</dd></dl><dl class="section__dl"><dt class="section__dt">Default：</dt><dd class="section__dd">null</dd></dl><p>可选，当点击导航菜单、文章中的 anchor 图标（#）或者上下滚动按钮会触发滚动，afterScroll() 回调函数会在滚动结束后触发执行。</p><h4 class="section__h4">Parameters</h4><h5 class="section__h4">target</h5><dl class="section__dl"><dt class="section__dt">Type：</dt><dd class="section__dd">String</dd></dl><p>afterScroll() 回调函数有一个参数 target，返回的是当前点击的 DOM 元素的名称：</p><ul><li>'anchor'：表示点击的是 anchor 图标，即文章中标题前的 “#” 图标，此时的 this 上下文指向 outline.anchors；</li><li>'chapter'：表示点击的是导航菜单的链接，此时的 this 上下文指向 outline.chapters；</li><li>'up'：表示点击的是工具栏的向上按钮，此时的 this 上下文指向 outline.toolbar；</li><li>'down'：表示点击的是工具栏的向下按钮，此时的 this 上下文指向 outline.toolbar；</li></ul><p>注意：因为配置 afterScroll 回调函数会因为 4 个不同的 DOM 触发，所以需要根据 target 返回的值和此时的 this 指向判断处理。</p><pre class="section__pre"><code class="section__code">const defaults = Outline.DEFAULTS
let outline

defaults.position = 'fixed'
defaults.parentElement = '#aside'
defaults.stickyHeight = 86
defaults.homepage = './index.html'
defaults.afterScroll = function(target) {
  // 当然，如果你希望无论是点击什么都执行，就不需要判断了
  // 直接些通用的滚动结束的逻辑即可
  switch(target){
    case 'anchor':
      // 针对点击 # 的处理逻辑
      break
    case 'chapter':
      // 针对点击导航菜单的处理逻辑
      break
    case 'up':
      // 针对点击向上滚动按钮的处理逻辑
      break
    case 'down':
      // 针对点击向下滚动按钮的处理逻辑
      break
  }
}
outline = new Outline(Outline.DEFAULTS)</code></pre></div></section><section class="section"><header class="section__header"><h3 class="section__h3">clone(el[, deep])</h3></header><div class="section__content"><h4 class="section__h4">Description</h4><dl class="section__dl"><dt class="section__dt">Type：</dt><dd class="section__dd">Function</dd></dl><dl class="section__dl"><dt class="section__dt">Default：</dt><dd class="section__dd">null</dd></dl><p>可选，当点击导航菜单、文章中的 anchor 图标（#）或者上下滚动按钮会触发滚动，afterScroll() 回调函数会在滚动结束后触发执行。</p><h4 class="section__h4">Parameters</h4><h5 class="section__h4">target</h5><dl class="section__dl"><dt class="section__dt">Type：</dt><dd class="section__dd">String</dd></dl><p>afterScroll() 回调函数有一个参数 target，返回的是当前点击的 DOM 元素的名称：</p><ul><li>'anchor'：表示点击的是 anchor 图标，即文章中标题前的 “#” 图标，此时的 this 上下文指向 outline.anchors；</li><li>'chapter'：表示点击的是导航菜单的链接，此时的 this 上下文指向 outline.chapters；</li><li>'up'：表示点击的是工具栏的向上按钮，此时的 this 上下文指向 outline.toolbar；</li><li>'down'：表示点击的是工具栏的向下按钮，此时的 this 上下文指向 outline.toolbar；</li></ul><p>注意：因为配置 afterScroll 回调函数会因为 4 个不同的 DOM 触发，所以需要根据 target 返回的值和此时的 this 指向判断处理。</p><pre class="section__pre"><code class="section__code">const defaults = Outline.DEFAULTS
let outline

defaults.position = 'fixed'
defaults.parentElement = '#aside'
defaults.stickyHeight = 86
defaults.homepage = './index.html'
defaults.afterScroll = function(target) {
  // 当然，如果你希望无论是点击什么都执行，就不需要判断了
  // 直接些通用的滚动结束的逻辑即可
  switch(target){
    case 'anchor':
      // 针对点击 # 的处理逻辑
      break
    case 'chapter':
      // 针对点击导航菜单的处理逻辑
      break
    case 'up':
      // 针对点击向上滚动按钮的处理逻辑
      break
    case 'down':
      // 针对点击向下滚动按钮的处理逻辑
      break
  }
}
outline = new Outline(Outline.DEFAULTS)</code></pre></div></section><section class="section"><header class="section__header"><h3 class="section__h3">closet(el, selector[, ctx, includeCTX])</h3></header><div class="section__content"><h4 class="section__h4">Description</h4><dl class="section__dl"><dt class="section__dt">Type：</dt><dd class="section__dd">Function</dd></dl><dl class="section__dl"><dt class="section__dt">Default：</dt><dd class="section__dd">null</dd></dl><p>可选，当点击导航菜单、文章中的 anchor 图标（#）或者上下滚动按钮会触发滚动，afterScroll() 回调函数会在滚动结束后触发执行。</p><h4 class="section__h4">Parameters</h4><h5 class="section__h4">target</h5><dl class="section__dl"><dt class="section__dt">Type：</dt><dd class="section__dd">String</dd></dl><p>afterScroll() 回调函数有一个参数 target，返回的是当前点击的 DOM 元素的名称：</p><ul><li>'anchor'：表示点击的是 anchor 图标，即文章中标题前的 “#” 图标，此时的 this 上下文指向 outline.anchors；</li><li>'chapter'：表示点击的是导航菜单的链接，此时的 this 上下文指向 outline.chapters；</li><li>'up'：表示点击的是工具栏的向上按钮，此时的 this 上下文指向 outline.toolbar；</li><li>'down'：表示点击的是工具栏的向下按钮，此时的 this 上下文指向 outline.toolbar；</li></ul><p>注意：因为配置 afterScroll 回调函数会因为 4 个不同的 DOM 触发，所以需要根据 target 返回的值和此时的 this 指向判断处理。</p><pre class="section__pre"><code class="section__code">const defaults = Outline.DEFAULTS
let outline

defaults.position = 'fixed'
defaults.parentElement = '#aside'
defaults.stickyHeight = 86
defaults.homepage = './index.html'
defaults.afterScroll = function(target) {
  // 当然，如果你希望无论是点击什么都执行，就不需要判断了
  // 直接些通用的滚动结束的逻辑即可
  switch(target){
    case 'anchor':
      // 针对点击 # 的处理逻辑
      break
    case 'chapter':
      // 针对点击导航菜单的处理逻辑
      break
    case 'up':
      // 针对点击向上滚动按钮的处理逻辑
      break
    case 'down':
      // 针对点击向下滚动按钮的处理逻辑
      break
  }
}
outline = new Outline(Outline.DEFAULTS)</code></pre></div></section><section class="section"><header class="section__header"><h3 class="section__h3">contains(ancestor, descendent)</h3></header><div class="section__content"><h4 class="section__h4">Description</h4><dl class="section__dl"><dt class="section__dt">Type：</dt><dd class="section__dd">Function</dd></dl><dl class="section__dl"><dt class="section__dt">Default：</dt><dd class="section__dd">null</dd></dl><p>可选，当点击导航菜单、文章中的 anchor 图标（#）或者上下滚动按钮会触发滚动，afterScroll() 回调函数会在滚动结束后触发执行。</p><h4 class="section__h4">Parameters</h4><h5 class="section__h4">target</h5><dl class="section__dl"><dt class="section__dt">Type：</dt><dd class="section__dd">String</dd></dl><p>afterScroll() 回调函数有一个参数 target，返回的是当前点击的 DOM 元素的名称：</p><ul><li>'anchor'：表示点击的是 anchor 图标，即文章中标题前的 “#” 图标，此时的 this 上下文指向 outline.anchors；</li><li>'chapter'：表示点击的是导航菜单的链接，此时的 this 上下文指向 outline.chapters；</li><li>'up'：表示点击的是工具栏的向上按钮，此时的 this 上下文指向 outline.toolbar；</li><li>'down'：表示点击的是工具栏的向下按钮，此时的 this 上下文指向 outline.toolbar；</li></ul><p>注意：因为配置 afterScroll 回调函数会因为 4 个不同的 DOM 触发，所以需要根据 target 返回的值和此时的 this 指向判断处理。</p><pre class="section__pre"><code class="section__code">const defaults = Outline.DEFAULTS
let outline

defaults.position = 'fixed'
defaults.parentElement = '#aside'
defaults.stickyHeight = 86
defaults.homepage = './index.html'
defaults.afterScroll = function(target) {
  // 当然，如果你希望无论是点击什么都执行，就不需要判断了
  // 直接些通用的滚动结束的逻辑即可
  switch(target){
    case 'anchor':
      // 针对点击 # 的处理逻辑
      break
    case 'chapter':
      // 针对点击导航菜单的处理逻辑
      break
    case 'up':
      // 针对点击向上滚动按钮的处理逻辑
      break
    case 'down':
      // 针对点击向下滚动按钮的处理逻辑
      break
  }
}
outline = new Outline(Outline.DEFAULTS)</code></pre></div></section><section class="section"><header class="section__header"><h3 class="section__h3">byClass(className, el)</h3></header><div class="section__content"><h4 class="section__h4">Description</h4><dl class="section__dl"><dt class="section__dt">Type：</dt><dd class="section__dd">String|HTMLElement</dd></dl><dl class="section__dl"><dt class="section__dt">Default：</dt><dd class="section__dd">'html,body'</dd></dl><ul><li>String： 选择器字符串，默认值：html,body（即 window 窗口）;</li><li>HTMLElement： DOM 元素;</li></ul><p>可选，负责文章区域滚动的元素：</p><pre class="section__pre"><code class="section__">// 默认是当前窗口滚动
new Outline(Outline.DEFAULTS)

// 指定滚动区域是 #main 元素
new Outline({
  scrollElement: '#main'
})</code></pre></div></section><section class="section"><header class="section__header"><h3 class="section__h3">byId(id, el)</h3></header><div class="section__content"><h4 class="section__h4">Description</h4><dl class="section__dl"><dt class="section__dt">Type：</dt><dd class="section__dd">String|HTMLElement</dd></dl><dl class="section__dl"><dt class="section__dt">Default：</dt><dd class="section__dd">'html,body'</dd></dl><ul><li>String： 选择器字符串，默认值：html,body（即 window 窗口）;</li><li>HTMLElement： DOM 元素;</li></ul><p>可选，负责文章区域滚动的元素：</p><pre class="section__pre"><code class="section__">// 默认是当前窗口滚动
new Outline(Outline.DEFAULTS)

// 指定滚动区域是 #main 元素
new Outline({
  scrollElement: '#main'
})</code></pre></div></section><section class="section"><header class="section__header"><h3 class="section__h3">getEl(selector, el, multiple)</h3></header><div class="section__content"><h4 class="section__h4">Description</h4><dl class="section__dl"><dt class="section__dt">Type：</dt><dd class="section__dd">String|HTMLElement</dd></dl><dl class="section__dl"><dt class="section__dt">Default：</dt><dd class="section__dd">'html,body'</dd></dl><ul><li>String： 选择器字符串，默认值：html,body（即 window 窗口）;</li><li>HTMLElement： DOM 元素;</li></ul><p>可选，负责文章区域滚动的元素：</p><pre class="section__pre"><code class="section__">// 默认是当前窗口滚动
new Outline(Outline.DEFAULTS)

// 指定滚动区域是 #main 元素
new Outline({
  scrollElement: '#main'
})</code></pre></div></section><section class="section"><header class="section__header"><h3 class="section__h3">getHostOrParent(el)</h3></header><div class="section__content"><h4 class="section__h4">Description</h4><dl class="section__dl"><dt class="section__dt">Type：</dt><dd class="section__dd">Object</dd></dl><p>Anchors 模块：类似 AnchorJS 基础功能模块，自动分析段落层级。</p><pre class="section__pre"><code class="section__code">// 仅展示 API 中对外公开的方法和属性
class Anchors extends Base {
  constructor(options) {
    super()

    this.attrs = Anchors.DEFAULTS
    this.$articleElement = null
    this.$scrollElement = null
    this.$headings = []
    this.chapters = []

    // 省略其它逻辑...
  }

  getChapters(isTreeStructured = false) {
    const chapters = this.chapters
    return isTreeStructured ? toTree(chapters, 'id', 'pid') : chapters
  }

  count() {
    return this.chapters.length
  }

  attrs(prop, value) {
    const attrs = this.attrs

    if (isString(prop)) {
      // 只能扩展 attrs 中已有的属性
      if (value && hasOwn(attrs, prop)) {
        // 更新单个配置信息
        attrs[prop] = value
        return this
      }

      // 只传递 prop 参数，则返回对应的属性值
      return attrs[prop]
    } else if (isObject(prop)) {
      // 批量更新配置信息
      extend(attrs, prop)

      return this
    } else if (arguments.length === 0) {
      // 不传递参数，直接返回整个
      return attrs
    }

    return this
  }

  render() {
    // 省略其它逻辑...
    return this
  }

  scrollTo(top, after) {
    // 省略其它逻辑...
    return this
  }

  destroy() {
    this.removeListeners()
    // 省略其它逻辑...
    return this
  }

  reload(options) {
    this.destroy().initialize(this.attrs(options))
    return this
  }
}

Anchors.DEFAULTS = {
  scrollElement: 'html,body',
  articleElement: '#article',
  selector: 'h1,h2,h3,h4,h5,h6',
  anchorURL: '',
  hasAnchor: true,
  isAtStart: true,
  showCode: false,
  created: null,
  mounted: null,
  afterScroll: null,
  beforeDestroy: null,
  afterDestroy: null
}

export default Anchors</code></pre></div></section><section class="section"><header class="section__header"><h3 class="section__h3">getOffsetParent(el)</h3></header><div class="section__content"><h4 class="section__h4">Description</h4><dl class="section__dl"><dt class="section__dt">Type：</dt><dd class="section__dd">Object</dd></dl><p>Anchors 模块：类似 AnchorJS 基础功能模块，自动分析段落层级。</p><pre class="section__pre"><code class="section__code">// 仅展示 API 中对外公开的方法和属性
class Anchors extends Base {
  constructor(options) {
    super()

    this.attrs = Anchors.DEFAULTS
    this.$articleElement = null
    this.$scrollElement = null
    this.$headings = []
    this.chapters = []

    // 省略其它逻辑...
  }

  getChapters(isTreeStructured = false) {
    const chapters = this.chapters
    return isTreeStructured ? toTree(chapters, 'id', 'pid') : chapters
  }

  count() {
    return this.chapters.length
  }

  attrs(prop, value) {
    const attrs = this.attrs

    if (isString(prop)) {
      // 只能扩展 attrs 中已有的属性
      if (value && hasOwn(attrs, prop)) {
        // 更新单个配置信息
        attrs[prop] = value
        return this
      }

      // 只传递 prop 参数，则返回对应的属性值
      return attrs[prop]
    } else if (isObject(prop)) {
      // 批量更新配置信息
      extend(attrs, prop)

      return this
    } else if (arguments.length === 0) {
      // 不传递参数，直接返回整个
      return attrs
    }

    return this
  }

  render() {
    // 省略其它逻辑...
    return this
  }

  scrollTo(top, after) {
    // 省略其它逻辑...
    return this
  }

  destroy() {
    this.removeListeners()
    // 省略其它逻辑...
    return this
  }

  reload(options) {
    this.destroy().initialize(this.attrs(options))
    return this
  }
}

Anchors.DEFAULTS = {
  scrollElement: 'html,body',
  articleElement: '#article',
  selector: 'h1,h2,h3,h4,h5,h6',
  anchorURL: '',
  hasAnchor: true,
  isAtStart: true,
  showCode: false,
  created: null,
  mounted: null,
  afterScroll: null,
  beforeDestroy: null,
  afterDestroy: null
}

export default Anchors</code></pre></div></section><section class="section"><header class="section__header"><h3 class="section__h3">getScrollParent(el)</h3></header><div class="section__content"><h4 class="section__h4">Description</h4><dl class="section__dl"><dt class="section__dt">Type：</dt><dd class="section__dd">Object</dd></dl><p>Anchors 模块：类似 AnchorJS 基础功能模块，自动分析段落层级。</p><pre class="section__pre"><code class="section__code">// 仅展示 API 中对外公开的方法和属性
class Anchors extends Base {
  constructor(options) {
    super()

    this.attrs = Anchors.DEFAULTS
    this.$articleElement = null
    this.$scrollElement = null
    this.$headings = []
    this.chapters = []

    // 省略其它逻辑...
  }

  getChapters(isTreeStructured = false) {
    const chapters = this.chapters
    return isTreeStructured ? toTree(chapters, 'id', 'pid') : chapters
  }

  count() {
    return this.chapters.length
  }

  attrs(prop, value) {
    const attrs = this.attrs

    if (isString(prop)) {
      // 只能扩展 attrs 中已有的属性
      if (value && hasOwn(attrs, prop)) {
        // 更新单个配置信息
        attrs[prop] = value
        return this
      }

      // 只传递 prop 参数，则返回对应的属性值
      return attrs[prop]
    } else if (isObject(prop)) {
      // 批量更新配置信息
      extend(attrs, prop)

      return this
    } else if (arguments.length === 0) {
      // 不传递参数，直接返回整个
      return attrs
    }

    return this
  }

  render() {
    // 省略其它逻辑...
    return this
  }

  scrollTo(top, after) {
    // 省略其它逻辑...
    return this
  }

  destroy() {
    this.removeListeners()
    // 省略其它逻辑...
    return this
  }

  reload(options) {
    this.destroy().initialize(this.attrs(options))
    return this
  }
}

Anchors.DEFAULTS = {
  scrollElement: 'html,body',
  articleElement: '#article',
  selector: 'h1,h2,h3,h4,h5,h6',
  anchorURL: '',
  hasAnchor: true,
  isAtStart: true,
  showCode: false,
  created: null,
  mounted: null,
  afterScroll: null,
  beforeDestroy: null,
  afterDestroy: null
}

export default Anchors</code></pre></div></section><section class="section"><header class="section__header"><h3 class="section__h3">index(ancestor[, descendent])</h3></header><div class="section__content"><h4 class="section__h4">Description</h4><dl class="section__dl"><dt class="section__dt">Type：</dt><dd class="section__dd">String|HTMLElement</dd></dl><dl class="section__dl"><dt class="section__dt">Default：</dt><dd class="section__dd">'html,body'</dd></dl><ul><li>String： 选择器字符串，默认值：html,body（即 window 窗口）;</li><li>HTMLElement： DOM 元素;</li></ul><p>可选，负责文章区域滚动的元素：</p><pre class="section__pre"><code class="section__">// 默认是当前窗口滚动
new Outline(Outline.DEFAULTS)

// 指定滚动区域是 #main 元素
new Outline({
  scrollElement: '#main'
})</code></pre></div></section><section class="section"><header class="section__header"><h3 class="section__h3">isAncestor(ancestor, descendent)</h3></header><div class="section__content"><h4 class="section__h4">Description</h4><dl class="section__dl"><dt class="section__dt">Type：</dt><dd class="section__dd">Function</dd></dl><dl class="section__dl"><dt class="section__dt">Default：</dt><dd class="section__dd">null</dd></dl><p>可选，当点击导航菜单、文章中的 anchor 图标（#）或者上下滚动按钮会触发滚动，afterScroll() 回调函数会在滚动结束后触发执行。</p><h4 class="section__h4">Parameters</h4><h5 class="section__h4">target</h5><dl class="section__dl"><dt class="section__dt">Type：</dt><dd class="section__dd">String</dd></dl><p>afterScroll() 回调函数有一个参数 target，返回的是当前点击的 DOM 元素的名称：</p><ul><li>'anchor'：表示点击的是 anchor 图标，即文章中标题前的 “#” 图标，此时的 this 上下文指向 outline.anchors；</li><li>'chapter'：表示点击的是导航菜单的链接，此时的 this 上下文指向 outline.chapters；</li><li>'up'：表示点击的是工具栏的向上按钮，此时的 this 上下文指向 outline.toolbar；</li><li>'down'：表示点击的是工具栏的向下按钮，此时的 this 上下文指向 outline.toolbar；</li></ul><p>注意：因为配置 afterScroll 回调函数会因为 4 个不同的 DOM 触发，所以需要根据 target 返回的值和此时的 this 指向判断处理。</p><pre class="section__pre"><code class="section__code">const defaults = Outline.DEFAULTS
let outline

defaults.position = 'fixed'
defaults.parentElement = '#aside'
defaults.stickyHeight = 86
defaults.homepage = './index.html'
defaults.afterScroll = function(target) {
  // 当然，如果你希望无论是点击什么都执行，就不需要判断了
  // 直接些通用的滚动结束的逻辑即可
  switch(target){
    case 'anchor':
      // 针对点击 # 的处理逻辑
      break
    case 'chapter':
      // 针对点击导航菜单的处理逻辑
      break
    case 'up':
      // 针对点击向上滚动按钮的处理逻辑
      break
    case 'down':
      // 针对点击向下滚动按钮的处理逻辑
      break
  }
}
outline = new Outline(Outline.DEFAULTS)</code></pre></div></section><section class="section"><header class="section__header"><h3 class="section__h3">isInViewport(el)</h3></header><div class="section__content"><h4 class="section__h4">Description</h4><dl class="section__dl"><dt class="section__dt">Type：</dt><dd class="section__dd">String|HTMLElement</dd></dl><dl class="section__dl"><dt class="section__dt">Default：</dt><dd class="section__dd">'html,body'</dd></dl><ul><li>String： 选择器字符串，默认值：html,body（即 window 窗口）;</li><li>HTMLElement： DOM 元素;</li></ul><p>可选，负责文章区域滚动的元素：</p><pre class="section__pre"><code class="section__">// 默认是当前窗口滚动
new Outline(Outline.DEFAULTS)

// 指定滚动区域是 #main 元素
new Outline({
  scrollElement: '#main'
})</code></pre></div></section><section class="section"><header class="section__header"><h3 class="section__h3">isMatched(el, filter)</h3></header><div class="section__content"><h4 class="section__h4">Description</h4><dl class="section__dl"><dt class="section__dt">Type：</dt><dd class="section__dd">String|HTMLElement</dd></dl><dl class="section__dl"><dt class="section__dt">Default：</dt><dd class="section__dd">'html,body'</dd></dl><ul><li>String： 选择器字符串，默认值：html,body（即 window 窗口）;</li><li>HTMLElement： DOM 元素;</li></ul><p>可选，负责文章区域滚动的元素：</p><pre class="section__pre"><code class="section__">// 默认是当前窗口滚动
new Outline(Outline.DEFAULTS)

// 指定滚动区域是 #main 元素
new Outline({
  scrollElement: '#main'
})</code></pre></div></section><section class="section"><header class="section__header"><h3 class="section__h3">matches(el, selector)</h3></header><div class="section__content"><h4 class="section__h4">Description</h4><dl class="section__dl"><dt class="section__dt">Type：</dt><dd class="section__dd">Function</dd></dl><dl class="section__dl"><dt class="section__dt">Default：</dt><dd class="section__dd">null</dd></dl><p>可选，当点击导航菜单、文章中的 anchor 图标（#）或者上下滚动按钮会触发滚动，afterScroll() 回调函数会在滚动结束后触发执行。</p><h4 class="section__h4">Parameters</h4><h5 class="section__h4">target</h5><dl class="section__dl"><dt class="section__dt">Type：</dt><dd class="section__dd">String</dd></dl><p>afterScroll() 回调函数有一个参数 target，返回的是当前点击的 DOM 元素的名称：</p><ul><li>'anchor'：表示点击的是 anchor 图标，即文章中标题前的 “#” 图标，此时的 this 上下文指向 outline.anchors；</li><li>'chapter'：表示点击的是导航菜单的链接，此时的 this 上下文指向 outline.chapters；</li><li>'up'：表示点击的是工具栏的向上按钮，此时的 this 上下文指向 outline.toolbar；</li><li>'down'：表示点击的是工具栏的向下按钮，此时的 this 上下文指向 outline.toolbar；</li></ul><p>注意：因为配置 afterScroll 回调函数会因为 4 个不同的 DOM 触发，所以需要根据 target 返回的值和此时的 this 指向判断处理。</p><pre class="section__pre"><code class="section__code">const defaults = Outline.DEFAULTS
let outline

defaults.position = 'fixed'
defaults.parentElement = '#aside'
defaults.stickyHeight = 86
defaults.homepage = './index.html'
defaults.afterScroll = function(target) {
  // 当然，如果你希望无论是点击什么都执行，就不需要判断了
  // 直接些通用的滚动结束的逻辑即可
  switch(target){
    case 'anchor':
      // 针对点击 # 的处理逻辑
      break
    case 'chapter':
      // 针对点击导航菜单的处理逻辑
      break
    case 'up':
      // 针对点击向上滚动按钮的处理逻辑
      break
    case 'down':
      // 针对点击向下滚动按钮的处理逻辑
      break
  }
}
outline = new Outline(Outline.DEFAULTS)</code></pre></div></section><section class="section"><header class="section__header"><h3 class="section__h3">parent(el)</h3></header><div class="section__content"><h4 class="section__h4">Description</h4><dl class="section__dl"><dt class="section__dt">Type：</dt><dd class="section__dd">Function</dd></dl><dl class="section__dl"><dt class="section__dt">Default：</dt><dd class="section__dd">null</dd></dl><p>可选，当点击导航菜单、文章中的 anchor 图标（#）或者上下滚动按钮会触发滚动，afterScroll() 回调函数会在滚动结束后触发执行。</p><h4 class="section__h4">Parameters</h4><h5 class="section__h4">target</h5><dl class="section__dl"><dt class="section__dt">Type：</dt><dd class="section__dd">String</dd></dl><p>afterScroll() 回调函数有一个参数 target，返回的是当前点击的 DOM 元素的名称：</p><ul><li>'anchor'：表示点击的是 anchor 图标，即文章中标题前的 “#” 图标，此时的 this 上下文指向 outline.anchors；</li><li>'chapter'：表示点击的是导航菜单的链接，此时的 this 上下文指向 outline.chapters；</li><li>'up'：表示点击的是工具栏的向上按钮，此时的 this 上下文指向 outline.toolbar；</li><li>'down'：表示点击的是工具栏的向下按钮，此时的 this 上下文指向 outline.toolbar；</li></ul><p>注意：因为配置 afterScroll 回调函数会因为 4 个不同的 DOM 触发，所以需要根据 target 返回的值和此时的 this 指向判断处理。</p><pre class="section__pre"><code class="section__code">const defaults = Outline.DEFAULTS
let outline

defaults.position = 'fixed'
defaults.parentElement = '#aside'
defaults.stickyHeight = 86
defaults.homepage = './index.html'
defaults.afterScroll = function(target) {
  // 当然，如果你希望无论是点击什么都执行，就不需要判断了
  // 直接些通用的滚动结束的逻辑即可
  switch(target){
    case 'anchor':
      // 针对点击 # 的处理逻辑
      break
    case 'chapter':
      // 针对点击导航菜单的处理逻辑
      break
    case 'up':
      // 针对点击向上滚动按钮的处理逻辑
      break
    case 'down':
      // 针对点击向下滚动按钮的处理逻辑
      break
  }
}
outline = new Outline(Outline.DEFAULTS)</code></pre></div></section><section class="section"><header class="section__header"><h3 class="section__h3">children(el)</h3></header><div class="section__content"><h4 class="section__h4">Description</h4><dl class="section__dl"><dt class="section__dt">Type：</dt><dd class="section__dd">Function</dd></dl><dl class="section__dl"><dt class="section__dt">Default：</dt><dd class="section__dd">null</dd></dl><p>可选，当点击导航菜单、文章中的 anchor 图标（#）或者上下滚动按钮会触发滚动，afterScroll() 回调函数会在滚动结束后触发执行。</p><h4 class="section__h4">Parameters</h4><h5 class="section__h4">target</h5><dl class="section__dl"><dt class="section__dt">Type：</dt><dd class="section__dd">String</dd></dl><p>afterScroll() 回调函数有一个参数 target，返回的是当前点击的 DOM 元素的名称：</p><ul><li>'anchor'：表示点击的是 anchor 图标，即文章中标题前的 “#” 图标，此时的 this 上下文指向 outline.anchors；</li><li>'chapter'：表示点击的是导航菜单的链接，此时的 this 上下文指向 outline.chapters；</li><li>'up'：表示点击的是工具栏的向上按钮，此时的 this 上下文指向 outline.toolbar；</li><li>'down'：表示点击的是工具栏的向下按钮，此时的 this 上下文指向 outline.toolbar；</li></ul><p>注意：因为配置 afterScroll 回调函数会因为 4 个不同的 DOM 触发，所以需要根据 target 返回的值和此时的 this 指向判断处理。</p><pre class="section__pre"><code class="section__code">const defaults = Outline.DEFAULTS
let outline

defaults.position = 'fixed'
defaults.parentElement = '#aside'
defaults.stickyHeight = 86
defaults.homepage = './index.html'
defaults.afterScroll = function(target) {
  // 当然，如果你希望无论是点击什么都执行，就不需要判断了
  // 直接些通用的滚动结束的逻辑即可
  switch(target){
    case 'anchor':
      // 针对点击 # 的处理逻辑
      break
    case 'chapter':
      // 针对点击导航菜单的处理逻辑
      break
    case 'up':
      // 针对点击向上滚动按钮的处理逻辑
      break
    case 'down':
      // 针对点击向下滚动按钮的处理逻辑
      break
  }
}
outline = new Outline(Outline.DEFAULTS)</code></pre></div></section></section><section class="section"><header class="section__header"><h2 class="section__title">DOM Insertion</h2></header><div class="section__content"><p>dom.js 提供以下方法用于处理插入新的 DOM 元素。</p></div><section class="section"><header class="section__header"><h3 class="section__h3">insertAfter(el, reference)</h3></header><div class="section__content"><h4 class="section__h4">Description</h4><dl class="section__dl"><dt class="section__dt">Type：</dt><dd class="section__dd">String|HTMLElement</dd></dl><dl class="section__dl"><dt class="section__dt">Default：</dt><dd class="section__dd">'#article'</dd></dl><dl class="section__dl"><dt class="section__dt">String：</dt><dd class="section__dd">选择器字符串，默认值：html,body（即 window 窗口）;</dd></dl><dl class="section__dl"><dt class="section__dt">HTMLElement：</dt><dd class="section__dd">'DOM 元素;</dd></dl><p>可选，用来指定页面中显示文章正文的 DOM 节点或者选择器字符串。</p><pre class="section__pre"><code class="section__code">// Default Selector
const outline = new Outline(Outline.DEFAULTS)

// Customize Selector
const outline = new Outline({
  articleElement: $('#main')
})</code></pre></div></section><section class="section"><header class="section__header"><h3 class="section__h3">insertBefore(el, reference)</h3></header><div class="section__content"><h4 class="section__h4">Description</h4><dl class="section__dl"><dt class="section__dt">Type：</dt><dd class="section__dd">String</dd></dl><dl class="section__dl"><dt class="section__dt">Default：</dt><dd class="section__dd">''</dd></dl><p>可选，用来指定文章标题锚点链接图标的链接地址：</p><pre class="section__pre"><code class="section__code">// Default URL - 默认链接，点击图标，页面会滚动到当前标题位置
new Outline()

// Customize URL - 直接打开链接了
new Outline({
  anchorURL: 'http://www.yaohaixiao.com/'
})</code></pre></div></section><section class="section"><header class="section__header"><h3 class="section__h3">insertHTMLAfter(el, html)</h3></header><div class="section__content"><h4 class="section__h4">Description</h4><dl class="section__dl"><dt class="section__dt">Type：</dt><dd class="section__dd">String</dd></dl><dl class="section__dl"><dt class="section__dt">Default：</dt><dd class="section__dd">''</dd></dl><p>可选，(DIYer福利)设置自定义样式的 class 名称：</p><ul><li>'' - 采用默认 outline.js 的 UI 界面（默认值）；</li><li>设置自定义样式 - 自己根据需求设置个性化的 UI 界面；</li></ul><pre class="section__pre"><code class="section__code">// Default UI
new Outline(Outline.DEFAULTS)

// Customized
new Outline({
  // 设置深色配置界面
  customClass: 'theme-dark'
})</code></pre></div></section><section class="section"><header class="section__header"><h3 class="section__h3">insertHTMLBefore(el, html)</h3></header><div class="section__content"><h4 class="section__h4">Description</h4><dl class="section__dl"><dt class="section__dt">Type：</dt><dd class="section__dd">String</dd></dl><dl class="section__dl"><dt class="section__dt">Default：</dt><dd class="section__dd">''</dd></dl><p>可选，针对 API 文档类的文章页面，指定项目 git 仓库地址：</p><pre class="section__pre"><code class="section__code">const outline = new Outline(Outline.DEFAULTS)

// 侧边栏的 Toolbar 会多出一个 git 图标的按钮
outline.reload({
  git: 'https://github.com/yaohaixiao/outline.js'
})</code></pre></div></section><section class="section"><header class="section__header"><h3 class="section__h3">after(el, reference)</h3></header><div class="section__content"><h4 class="section__h4">Description</h4><dl class="section__dl"><dt class="section__dt">Type：</dt><dd class="section__dd">Function</dd></dl><dl class="section__dl"><dt class="section__dt">Default：</dt><dd class="section__dd">null</dd></dl><p>可选，当导航菜单隐藏或者显示的时候，会触发执行 afterToggle 回调函数。</p><p>说明：afterSticky() 回调函数的 this 上下文执行 outline.chapters 对象。</p><h4 class="section__h4">Parameters</h4><h5 class="section__h4">closed</h5><dl class="section__dl"><dt class="section__dt">Type：</dt><dd class="section__dd">Boolean</dd></dl><p>closed 参数值为 true 表示菜单处于隐藏状态，否则表示菜单处于显示状态</p><h5 class="section__h4">isSticky</h5><dl class="section__dl"><dt class="section__dt">Type：</dt><dd class="section__dd">Boolean</dd></dl><p>isSticky 参数值为 true 表示（position:fixed）菜单处于模拟 sticky 定位（position:fixed）状态，否则表示菜单处于普通状态。</p><pre class="section__pre"><code class="section__code">const $header = document.querySelector('#header')
const HEADER_STICKY = 'header_sticky'
const defaults = Outline.DEFAULTS
let outline

defaults.position = 'fixed'
defaults.parentElement = '#aside'
defaults.stickyHeight = 86
defaults.homepage = './index.html'
defaults.afterSticky = function(closed, isStickying) {
  const $nav = this.$el
  const BORDER_RIGHT = 'utils-border-right'

  if (closed) {
    return false
  }

  if (isStickying) {
    $nav.classList.add(BORDER_RIGHT)
    $header.classList.add(HEADER_STICKY)
  } else {
    $nav.classList.remove(BORDER_RIGHT)
    $header.classList.remove(HEADER_STICKY)
  }
}
defaults.afterToggle = function(closed, isStickying) {
  if (!isStickying) {
    return false
  }

  if (closed) {
    $header.classList.remove(HEADER_STICKY)
  } else {
    $header.classList.add(HEADER_STICKY)
  }
}
outline = new Outline(Outline.DEFAULTS)</code></pre></div></section><section class="section"><header class="section__header"><h3 class="section__h3">before(el, reference)</h3></header><div class="section__content"><h4 class="section__h4">Description</h4><dl class="section__dl"><dt class="section__dt">Type：</dt><dd class="section__dd">Function</dd></dl><dl class="section__dl"><dt class="section__dt">Default：</dt><dd class="section__dd">null</dd></dl><p>可选，API 文档中，正文的方法会添加参数等信息，例如：getChapters(headings, showCode, chapterTextFilter)。而在 chapters 导航菜单，我希望显示为 getChapters()，这时我们就可以借助 chapterTextFilter 回调函数。对原始的文本进行过滤，返回我们期望的 getChapters() 文本。</p><h4 class="section__h4">Parameters</h4><h5 class="section__h4">text</h5><dl class="section__dl"><dt class="section__dt">Type：</dt><dd class="section__dd">String</dd></dl><p>chapterTextFilter() 回调函数有一个参数 text，返回的是当前 hx 标题中的文本。</p><pre class="section__pre"><code class="section__code">const defaults = Outline.DEFAULTS
let outline

defaults.selector = 'h2,h3'
defaults.title = false
defaults.showCode = false
defaults.position = 'sticky'
defaults.parentElement = '#aside'
defaults.scrollElement = '#main'
defaults.articleElement = '#article'
defaults.homepage = './index.html'
defaults.git = 'https://github.com/yaohaixiao/outline.js'
defaults.tags = 'https://github.com/yaohaixiao/outline.js/tags'
defaults.issues = 'https://github.com/yaohaixiao/outline.js/issues'
defaults.print = {
  element: '#article',
  title: 'Outline.js'
}
defaults.chapterTextFilter = (text) => {
  return text.replace(/\(.*?\)/, '()')
}
outline = new Outline(Outline.DEFAULTS)</code></pre></div></section><section class="section"><header class="section__header"><h3 class="section__h3">append(el, reference)</h3></header><div class="section__content"><h4 class="section__h4">Description</h4><dl class="section__dl"><dt class="section__dt">Type：</dt><dd class="section__dd">Function</dd></dl><dl class="section__dl"><dt class="section__dt">Default：</dt><dd class="section__dd">null</dd></dl><p>可选，在设置 position: fixed 时，当导航菜单样式为 fixed 获取恢复为普通定位的时候，会触发执行 afterSticky 回调函数。</p><p>说明：afterSticky() 回调函数的 this 上下文执行 outline.chapters 对象。</p><h4 class="section__h4">Parameters</h4><h5 class="section__h4">closed</h5><dl class="section__dl"><dt class="section__dt">Type：</dt><dd class="section__dd">Boolean</dd></dl><p>closed 参数值为 true 表示菜单处于隐藏状态，否则表示菜单处于显示状态</p><h5 class="section__h4">isSticky</h5><dl class="section__dl"><dt class="section__dt">Type：</dt><dd class="section__dd">Boolean</dd></dl><p>isSticky 参数值为 true 表示（position:fixed）菜单处于模拟 sticky 定位（position:fixed）状态，否则表示菜单处于普通状态。</p><pre class="section__pre"><code class="section__code">const $header = document.querySelector('#header')
const HEADER_STICKY = 'header_sticky'
const defaults = Outline.DEFAULTS
let outline

defaults.position = 'fixed'
defaults.parentElement = '#aside'
defaults.stickyHeight = 86
defaults.homepage = './index.html'
defaults.afterSticky = function(closed, isStickying) {
  const $nav = this.$el
  const BORDER_RIGHT = 'utils-border-right'

  if (closed) {
    return false
  }

  if (isStickying) {
    $nav.classList.add(BORDER_RIGHT)
    $header.classList.add(HEADER_STICKY)
  } else {
    $nav.classList.remove(BORDER_RIGHT)
    $header.classList.remove(HEADER_STICKY)
  }
}
defaults.afterToggle = function(closed, isStickying) {
  if (!isStickying) {
    return false
  }

  if (closed) {
    $header.classList.remove(HEADER_STICKY)
  } else {
    $header.classList.add(HEADER_STICKY)
  }
}
outline = new Outline(Outline.DEFAULTS)</code></pre></div></section><section class="section"><header class="section__header"><h3 class="section__h3">prepend(el, reference)</h3></header><div class="section__content"><h4 class="section__h4">Description</h4><dl class="section__dl"><dt class="section__dt">Type：</dt><dd class="section__dd">Function</dd></dl><dl class="section__dl"><dt class="section__dt">Default：</dt><dd class="section__dd">null</dd></dl><p>可选，在设置 position: fixed 时，当导航菜单样式为 fixed 获取恢复为普通定位的时候，会触发执行 afterSticky 回调函数。</p><p>说明：afterSticky() 回调函数的 this 上下文执行 outline.chapters 对象。</p><h4 class="section__h4">Parameters</h4><h5 class="section__h4">closed</h5><dl class="section__dl"><dt class="section__dt">Type：</dt><dd class="section__dd">Boolean</dd></dl><p>closed 参数值为 true 表示菜单处于隐藏状态，否则表示菜单处于显示状态</p><h5 class="section__h4">isSticky</h5><dl class="section__dl"><dt class="section__dt">Type：</dt><dd class="section__dd">Boolean</dd></dl><p>isSticky 参数值为 true 表示（position:fixed）菜单处于模拟 sticky 定位（position:fixed）状态，否则表示菜单处于普通状态。</p><pre class="section__pre"><code class="section__code">const $header = document.querySelector('#header')
const HEADER_STICKY = 'header_sticky'
const defaults = Outline.DEFAULTS
let outline

defaults.position = 'fixed'
defaults.parentElement = '#aside'
defaults.stickyHeight = 86
defaults.homepage = './index.html'
defaults.afterSticky = function(closed, isStickying) {
  const $nav = this.$el
  const BORDER_RIGHT = 'utils-border-right'

  if (closed) {
    return false
  }

  if (isStickying) {
    $nav.classList.add(BORDER_RIGHT)
    $header.classList.add(HEADER_STICKY)
  } else {
    $nav.classList.remove(BORDER_RIGHT)
    $header.classList.remove(HEADER_STICKY)
  }
}
defaults.afterToggle = function(closed, isStickying) {
  if (!isStickying) {
    return false
  }

  if (closed) {
    $header.classList.remove(HEADER_STICKY)
  } else {
    $header.classList.add(HEADER_STICKY)
  }
}
outline = new Outline(Outline.DEFAULTS)</code></pre></div></section></section><section class="section"><header class="section__header"><h2 class="section__title">Position</h2></header><div class="section__content"><p>dom.js 提供以下几个方法用于获 DOM 元素的位置（offsetTop、offsetLeft、scrollTop、scrollLeft、pageX 和 pageY 等）信息。</p></div><section class="section"><header class="section__header"><h3 class="section__h3">getOffset(el)</h3></header><div class="section__content"><h4 class="section__h4">Description</h4><dl class="section__dl"><dt class="section__dt">Type：</dt><dd class="section__dd">Object</dd></dl><p>Anchors 模块：类似 AnchorJS 基础功能模块，自动分析段落层级。</p><pre class="section__pre"><code class="section__code">// 仅展示 API 中对外公开的方法和属性
class Anchors extends Base {
  constructor(options) {
    super()

    this.attrs = Anchors.DEFAULTS
    this.$articleElement = null
    this.$scrollElement = null
    this.$headings = []
    this.chapters = []

    // 省略其它逻辑...
  }

  getChapters(isTreeStructured = false) {
    const chapters = this.chapters
    return isTreeStructured ? toTree(chapters, 'id', 'pid') : chapters
  }

  count() {
    return this.chapters.length
  }

  attrs(prop, value) {
    const attrs = this.attrs

    if (isString(prop)) {
      // 只能扩展 attrs 中已有的属性
      if (value && hasOwn(attrs, prop)) {
        // 更新单个配置信息
        attrs[prop] = value
        return this
      }

      // 只传递 prop 参数，则返回对应的属性值
      return attrs[prop]
    } else if (isObject(prop)) {
      // 批量更新配置信息
      extend(attrs, prop)

      return this
    } else if (arguments.length === 0) {
      // 不传递参数，直接返回整个
      return attrs
    }

    return this
  }

  render() {
    // 省略其它逻辑...
    return this
  }

  scrollTo(top, after) {
    // 省略其它逻辑...
    return this
  }

  destroy() {
    this.removeListeners()
    // 省略其它逻辑...
    return this
  }

  reload(options) {
    this.destroy().initialize(this.attrs(options))
    return this
  }
}

Anchors.DEFAULTS = {
  scrollElement: 'html,body',
  articleElement: '#article',
  selector: 'h1,h2,h3,h4,h5,h6',
  anchorURL: '',
  hasAnchor: true,
  isAtStart: true,
  showCode: false,
  created: null,
  mounted: null,
  afterScroll: null,
  beforeDestroy: null,
  afterDestroy: null
}

export default Anchors</code></pre></div></section><section class="section"><header class="section__header"><h3 class="section__h3">getOffsetLeft(el)</h3></header><div class="section__content"><h4 class="section__h4">Description</h4><dl class="section__dl"><dt class="section__dt">Type：</dt><dd class="section__dd">Object</dd></dl><p>Anchors 模块：类似 AnchorJS 基础功能模块，自动分析段落层级。</p><pre class="section__pre"><code class="section__code">// 仅展示 API 中对外公开的方法和属性
class Anchors extends Base {
  constructor(options) {
    super()

    this.attrs = Anchors.DEFAULTS
    this.$articleElement = null
    this.$scrollElement = null
    this.$headings = []
    this.chapters = []

    // 省略其它逻辑...
  }

  getChapters(isTreeStructured = false) {
    const chapters = this.chapters
    return isTreeStructured ? toTree(chapters, 'id', 'pid') : chapters
  }

  count() {
    return this.chapters.length
  }

  attrs(prop, value) {
    const attrs = this.attrs

    if (isString(prop)) {
      // 只能扩展 attrs 中已有的属性
      if (value && hasOwn(attrs, prop)) {
        // 更新单个配置信息
        attrs[prop] = value
        return this
      }

      // 只传递 prop 参数，则返回对应的属性值
      return attrs[prop]
    } else if (isObject(prop)) {
      // 批量更新配置信息
      extend(attrs, prop)

      return this
    } else if (arguments.length === 0) {
      // 不传递参数，直接返回整个
      return attrs
    }

    return this
  }

  render() {
    // 省略其它逻辑...
    return this
  }

  scrollTo(top, after) {
    // 省略其它逻辑...
    return this
  }

  destroy() {
    this.removeListeners()
    // 省略其它逻辑...
    return this
  }

  reload(options) {
    this.destroy().initialize(this.attrs(options))
    return this
  }
}

Anchors.DEFAULTS = {
  scrollElement: 'html,body',
  articleElement: '#article',
  selector: 'h1,h2,h3,h4,h5,h6',
  anchorURL: '',
  hasAnchor: true,
  isAtStart: true,
  showCode: false,
  created: null,
  mounted: null,
  afterScroll: null,
  beforeDestroy: null,
  afterDestroy: null
}

export default Anchors</code></pre></div></section><section class="section"><header class="section__header"><h3 class="section__h3">getOffsetTop(el)</h3></header><div class="section__content"><h4 class="section__h4">Description</h4><dl class="section__dl"><dt class="section__dt">Type：</dt><dd class="section__dd">Object</dd></dl><p>Anchors 模块：类似 AnchorJS 基础功能模块，自动分析段落层级。</p><pre class="section__pre"><code class="section__code">// 仅展示 API 中对外公开的方法和属性
class Anchors extends Base {
  constructor(options) {
    super()

    this.attrs = Anchors.DEFAULTS
    this.$articleElement = null
    this.$scrollElement = null
    this.$headings = []
    this.chapters = []

    // 省略其它逻辑...
  }

  getChapters(isTreeStructured = false) {
    const chapters = this.chapters
    return isTreeStructured ? toTree(chapters, 'id', 'pid') : chapters
  }

  count() {
    return this.chapters.length
  }

  attrs(prop, value) {
    const attrs = this.attrs

    if (isString(prop)) {
      // 只能扩展 attrs 中已有的属性
      if (value && hasOwn(attrs, prop)) {
        // 更新单个配置信息
        attrs[prop] = value
        return this
      }

      // 只传递 prop 参数，则返回对应的属性值
      return attrs[prop]
    } else if (isObject(prop)) {
      // 批量更新配置信息
      extend(attrs, prop)

      return this
    } else if (arguments.length === 0) {
      // 不传递参数，直接返回整个
      return attrs
    }

    return this
  }

  render() {
    // 省略其它逻辑...
    return this
  }

  scrollTo(top, after) {
    // 省略其它逻辑...
    return this
  }

  destroy() {
    this.removeListeners()
    // 省略其它逻辑...
    return this
  }

  reload(options) {
    this.destroy().initialize(this.attrs(options))
    return this
  }
}

Anchors.DEFAULTS = {
  scrollElement: 'html,body',
  articleElement: '#article',
  selector: 'h1,h2,h3,h4,h5,h6',
  anchorURL: '',
  hasAnchor: true,
  isAtStart: true,
  showCode: false,
  created: null,
  mounted: null,
  afterScroll: null,
  beforeDestroy: null,
  afterDestroy: null
}

export default Anchors</code></pre></div></section><section class="section"><header class="section__header"><h3 class="section__h3">getPageXY(el)</h3></header><div class="section__content"><h4 class="section__h4">Description</h4><dl class="section__dl"><dt class="section__dt">Type：</dt><dd class="section__dd">Object</dd></dl><p>Anchors 模块：类似 AnchorJS 基础功能模块，自动分析段落层级。</p><pre class="section__pre"><code class="section__code">// 仅展示 API 中对外公开的方法和属性
class Anchors extends Base {
  constructor(options) {
    super()

    this.attrs = Anchors.DEFAULTS
    this.$articleElement = null
    this.$scrollElement = null
    this.$headings = []
    this.chapters = []

    // 省略其它逻辑...
  }

  getChapters(isTreeStructured = false) {
    const chapters = this.chapters
    return isTreeStructured ? toTree(chapters, 'id', 'pid') : chapters
  }

  count() {
    return this.chapters.length
  }

  attrs(prop, value) {
    const attrs = this.attrs

    if (isString(prop)) {
      // 只能扩展 attrs 中已有的属性
      if (value && hasOwn(attrs, prop)) {
        // 更新单个配置信息
        attrs[prop] = value
        return this
      }

      // 只传递 prop 参数，则返回对应的属性值
      return attrs[prop]
    } else if (isObject(prop)) {
      // 批量更新配置信息
      extend(attrs, prop)

      return this
    } else if (arguments.length === 0) {
      // 不传递参数，直接返回整个
      return attrs
    }

    return this
  }

  render() {
    // 省略其它逻辑...
    return this
  }

  scrollTo(top, after) {
    // 省略其它逻辑...
    return this
  }

  destroy() {
    this.removeListeners()
    // 省略其它逻辑...
    return this
  }

  reload(options) {
    this.destroy().initialize(this.attrs(options))
    return this
  }
}

Anchors.DEFAULTS = {
  scrollElement: 'html,body',
  articleElement: '#article',
  selector: 'h1,h2,h3,h4,h5,h6',
  anchorURL: '',
  hasAnchor: true,
  isAtStart: true,
  showCode: false,
  created: null,
  mounted: null,
  afterScroll: null,
  beforeDestroy: null,
  afterDestroy: null
}

export default Anchors</code></pre></div></section><section class="section"><header class="section__header"><h3 class="section__h3">getPageX(el)</h3></header><div class="section__content"><h4 class="section__h4">Description</h4><dl class="section__dl"><dt class="section__dt">Type：</dt><dd class="section__dd">Object</dd></dl><p>Anchors 模块：类似 AnchorJS 基础功能模块，自动分析段落层级。</p><pre class="section__pre"><code class="section__code">// 仅展示 API 中对外公开的方法和属性
class Anchors extends Base {
  constructor(options) {
    super()

    this.attrs = Anchors.DEFAULTS
    this.$articleElement = null
    this.$scrollElement = null
    this.$headings = []
    this.chapters = []

    // 省略其它逻辑...
  }

  getChapters(isTreeStructured = false) {
    const chapters = this.chapters
    return isTreeStructured ? toTree(chapters, 'id', 'pid') : chapters
  }

  count() {
    return this.chapters.length
  }

  attrs(prop, value) {
    const attrs = this.attrs

    if (isString(prop)) {
      // 只能扩展 attrs 中已有的属性
      if (value && hasOwn(attrs, prop)) {
        // 更新单个配置信息
        attrs[prop] = value
        return this
      }

      // 只传递 prop 参数，则返回对应的属性值
      return attrs[prop]
    } else if (isObject(prop)) {
      // 批量更新配置信息
      extend(attrs, prop)

      return this
    } else if (arguments.length === 0) {
      // 不传递参数，直接返回整个
      return attrs
    }

    return this
  }

  render() {
    // 省略其它逻辑...
    return this
  }

  scrollTo(top, after) {
    // 省略其它逻辑...
    return this
  }

  destroy() {
    this.removeListeners()
    // 省略其它逻辑...
    return this
  }

  reload(options) {
    this.destroy().initialize(this.attrs(options))
    return this
  }
}

Anchors.DEFAULTS = {
  scrollElement: 'html,body',
  articleElement: '#article',
  selector: 'h1,h2,h3,h4,h5,h6',
  anchorURL: '',
  hasAnchor: true,
  isAtStart: true,
  showCode: false,
  created: null,
  mounted: null,
  afterScroll: null,
  beforeDestroy: null,
  afterDestroy: null
}

export default Anchors</code></pre></div></section><section class="section"><header class="section__header"><h3 class="section__h3">getPageY(el)</h3></header><div class="section__content"><h4 class="section__h4">Description</h4><dl class="section__dl"><dt class="section__dt">Type：</dt><dd class="section__dd">Object</dd></dl><p>Anchors 模块：类似 AnchorJS 基础功能模块，自动分析段落层级。</p><pre class="section__pre"><code class="section__code">// 仅展示 API 中对外公开的方法和属性
class Anchors extends Base {
  constructor(options) {
    super()

    this.attrs = Anchors.DEFAULTS
    this.$articleElement = null
    this.$scrollElement = null
    this.$headings = []
    this.chapters = []

    // 省略其它逻辑...
  }

  getChapters(isTreeStructured = false) {
    const chapters = this.chapters
    return isTreeStructured ? toTree(chapters, 'id', 'pid') : chapters
  }

  count() {
    return this.chapters.length
  }

  attrs(prop, value) {
    const attrs = this.attrs

    if (isString(prop)) {
      // 只能扩展 attrs 中已有的属性
      if (value && hasOwn(attrs, prop)) {
        // 更新单个配置信息
        attrs[prop] = value
        return this
      }

      // 只传递 prop 参数，则返回对应的属性值
      return attrs[prop]
    } else if (isObject(prop)) {
      // 批量更新配置信息
      extend(attrs, prop)

      return this
    } else if (arguments.length === 0) {
      // 不传递参数，直接返回整个
      return attrs
    }

    return this
  }

  render() {
    // 省略其它逻辑...
    return this
  }

  scrollTo(top, after) {
    // 省略其它逻辑...
    return this
  }

  destroy() {
    this.removeListeners()
    // 省略其它逻辑...
    return this
  }

  reload(options) {
    this.destroy().initialize(this.attrs(options))
    return this
  }
}

Anchors.DEFAULTS = {
  scrollElement: 'html,body',
  articleElement: '#article',
  selector: 'h1,h2,h3,h4,h5,h6',
  anchorURL: '',
  hasAnchor: true,
  isAtStart: true,
  showCode: false,
  created: null,
  mounted: null,
  afterScroll: null,
  beforeDestroy: null,
  afterDestroy: null
}

export default Anchors</code></pre></div></section><section class="section"><header class="section__header"><h3 class="section__h3">getDocumentScrollLeft()</h3></header><div class="section__content"><h4 class="section__h4">Description</h4><dl class="section__dl"><dt class="section__dt">Type：</dt><dd class="section__dd">Object</dd></dl><p>Anchors 模块：类似 AnchorJS 基础功能模块，自动分析段落层级。</p><pre class="section__pre"><code class="section__code">// 仅展示 API 中对外公开的方法和属性
class Anchors extends Base {
  constructor(options) {
    super()

    this.attrs = Anchors.DEFAULTS
    this.$articleElement = null
    this.$scrollElement = null
    this.$headings = []
    this.chapters = []

    // 省略其它逻辑...
  }

  getChapters(isTreeStructured = false) {
    const chapters = this.chapters
    return isTreeStructured ? toTree(chapters, 'id', 'pid') : chapters
  }

  count() {
    return this.chapters.length
  }

  attrs(prop, value) {
    const attrs = this.attrs

    if (isString(prop)) {
      // 只能扩展 attrs 中已有的属性
      if (value && hasOwn(attrs, prop)) {
        // 更新单个配置信息
        attrs[prop] = value
        return this
      }

      // 只传递 prop 参数，则返回对应的属性值
      return attrs[prop]
    } else if (isObject(prop)) {
      // 批量更新配置信息
      extend(attrs, prop)

      return this
    } else if (arguments.length === 0) {
      // 不传递参数，直接返回整个
      return attrs
    }

    return this
  }

  render() {
    // 省略其它逻辑...
    return this
  }

  scrollTo(top, after) {
    // 省略其它逻辑...
    return this
  }

  destroy() {
    this.removeListeners()
    // 省略其它逻辑...
    return this
  }

  reload(options) {
    this.destroy().initialize(this.attrs(options))
    return this
  }
}

Anchors.DEFAULTS = {
  scrollElement: 'html,body',
  articleElement: '#article',
  selector: 'h1,h2,h3,h4,h5,h6',
  anchorURL: '',
  hasAnchor: true,
  isAtStart: true,
  showCode: false,
  created: null,
  mounted: null,
  afterScroll: null,
  beforeDestroy: null,
  afterDestroy: null
}

export default Anchors</code></pre></div></section><section class="section"><header class="section__header"><h3 class="section__h3">getDocumentScrollTop()</h3></header><div class="section__content"><h4 class="section__h4">Description</h4><dl class="section__dl"><dt class="section__dt">Type：</dt><dd class="section__dd">Object</dd></dl><p>Anchors 模块：类似 AnchorJS 基础功能模块，自动分析段落层级。</p><pre class="section__pre"><code class="section__code">// 仅展示 API 中对外公开的方法和属性
class Anchors extends Base {
  constructor(options) {
    super()

    this.attrs = Anchors.DEFAULTS
    this.$articleElement = null
    this.$scrollElement = null
    this.$headings = []
    this.chapters = []

    // 省略其它逻辑...
  }

  getChapters(isTreeStructured = false) {
    const chapters = this.chapters
    return isTreeStructured ? toTree(chapters, 'id', 'pid') : chapters
  }

  count() {
    return this.chapters.length
  }

  attrs(prop, value) {
    const attrs = this.attrs

    if (isString(prop)) {
      // 只能扩展 attrs 中已有的属性
      if (value && hasOwn(attrs, prop)) {
        // 更新单个配置信息
        attrs[prop] = value
        return this
      }

      // 只传递 prop 参数，则返回对应的属性值
      return attrs[prop]
    } else if (isObject(prop)) {
      // 批量更新配置信息
      extend(attrs, prop)

      return this
    } else if (arguments.length === 0) {
      // 不传递参数，直接返回整个
      return attrs
    }

    return this
  }

  render() {
    // 省略其它逻辑...
    return this
  }

  scrollTo(top, after) {
    // 省略其它逻辑...
    return this
  }

  destroy() {
    this.removeListeners()
    // 省略其它逻辑...
    return this
  }

  reload(options) {
    this.destroy().initialize(this.attrs(options))
    return this
  }
}

Anchors.DEFAULTS = {
  scrollElement: 'html,body',
  articleElement: '#article',
  selector: 'h1,h2,h3,h4,h5,h6',
  anchorURL: '',
  hasAnchor: true,
  isAtStart: true,
  showCode: false,
  created: null,
  mounted: null,
  afterScroll: null,
  beforeDestroy: null,
  afterDestroy: null
}

export default Anchors</code></pre></div></section><section class="section"><header class="section__header"><h3 class="section__h3">getScroll(el)</h3></header><div class="section__content"><h4 class="section__h4">Description</h4><dl class="section__dl"><dt class="section__dt">Type：</dt><dd class="section__dd">Object</dd></dl><p>Anchors 模块：类似 AnchorJS 基础功能模块，自动分析段落层级。</p><pre class="section__pre"><code class="section__code">// 仅展示 API 中对外公开的方法和属性
class Anchors extends Base {
  constructor(options) {
    super()

    this.attrs = Anchors.DEFAULTS
    this.$articleElement = null
    this.$scrollElement = null
    this.$headings = []
    this.chapters = []

    // 省略其它逻辑...
  }

  getChapters(isTreeStructured = false) {
    const chapters = this.chapters
    return isTreeStructured ? toTree(chapters, 'id', 'pid') : chapters
  }

  count() {
    return this.chapters.length
  }

  attrs(prop, value) {
    const attrs = this.attrs

    if (isString(prop)) {
      // 只能扩展 attrs 中已有的属性
      if (value && hasOwn(attrs, prop)) {
        // 更新单个配置信息
        attrs[prop] = value
        return this
      }

      // 只传递 prop 参数，则返回对应的属性值
      return attrs[prop]
    } else if (isObject(prop)) {
      // 批量更新配置信息
      extend(attrs, prop)

      return this
    } else if (arguments.length === 0) {
      // 不传递参数，直接返回整个
      return attrs
    }

    return this
  }

  render() {
    // 省略其它逻辑...
    return this
  }

  scrollTo(top, after) {
    // 省略其它逻辑...
    return this
  }

  destroy() {
    this.removeListeners()
    // 省略其它逻辑...
    return this
  }

  reload(options) {
    this.destroy().initialize(this.attrs(options))
    return this
  }
}

Anchors.DEFAULTS = {
  scrollElement: 'html,body',
  articleElement: '#article',
  selector: 'h1,h2,h3,h4,h5,h6',
  anchorURL: '',
  hasAnchor: true,
  isAtStart: true,
  showCode: false,
  created: null,
  mounted: null,
  afterScroll: null,
  beforeDestroy: null,
  afterDestroy: null
}

export default Anchors</code></pre></div></section><section class="section"><header class="section__header"><h3 class="section__h3">getScrollLeft(el)</h3></header><div class="section__content"><h4 class="section__h4">Description</h4><dl class="section__dl"><dt class="section__dt">Type：</dt><dd class="section__dd">Object</dd></dl><p>Anchors 模块：类似 AnchorJS 基础功能模块，自动分析段落层级。</p><pre class="section__pre"><code class="section__code">// 仅展示 API 中对外公开的方法和属性
class Anchors extends Base {
  constructor(options) {
    super()

    this.attrs = Anchors.DEFAULTS
    this.$articleElement = null
    this.$scrollElement = null
    this.$headings = []
    this.chapters = []

    // 省略其它逻辑...
  }

  getChapters(isTreeStructured = false) {
    const chapters = this.chapters
    return isTreeStructured ? toTree(chapters, 'id', 'pid') : chapters
  }

  count() {
    return this.chapters.length
  }

  attrs(prop, value) {
    const attrs = this.attrs

    if (isString(prop)) {
      // 只能扩展 attrs 中已有的属性
      if (value && hasOwn(attrs, prop)) {
        // 更新单个配置信息
        attrs[prop] = value
        return this
      }

      // 只传递 prop 参数，则返回对应的属性值
      return attrs[prop]
    } else if (isObject(prop)) {
      // 批量更新配置信息
      extend(attrs, prop)

      return this
    } else if (arguments.length === 0) {
      // 不传递参数，直接返回整个
      return attrs
    }

    return this
  }

  render() {
    // 省略其它逻辑...
    return this
  }

  scrollTo(top, after) {
    // 省略其它逻辑...
    return this
  }

  destroy() {
    this.removeListeners()
    // 省略其它逻辑...
    return this
  }

  reload(options) {
    this.destroy().initialize(this.attrs(options))
    return this
  }
}

Anchors.DEFAULTS = {
  scrollElement: 'html,body',
  articleElement: '#article',
  selector: 'h1,h2,h3,h4,h5,h6',
  anchorURL: '',
  hasAnchor: true,
  isAtStart: true,
  showCode: false,
  created: null,
  mounted: null,
  afterScroll: null,
  beforeDestroy: null,
  afterDestroy: null
}

export default Anchors</code></pre></div></section><section class="section"><header class="section__header"><h3 class="section__h3">getScrollTop(top)</h3></header><div class="section__content"><h4 class="section__h4">Description</h4><dl class="section__dl"><dt class="section__dt">Type：</dt><dd class="section__dd">Object</dd></dl><p>Anchors 模块：类似 AnchorJS 基础功能模块，自动分析段落层级。</p><pre class="section__pre"><code class="section__code">// 仅展示 API 中对外公开的方法和属性
class Anchors extends Base {
  constructor(options) {
    super()

    this.attrs = Anchors.DEFAULTS
    this.$articleElement = null
    this.$scrollElement = null
    this.$headings = []
    this.chapters = []

    // 省略其它逻辑...
  }

  getChapters(isTreeStructured = false) {
    const chapters = this.chapters
    return isTreeStructured ? toTree(chapters, 'id', 'pid') : chapters
  }

  count() {
    return this.chapters.length
  }

  attrs(prop, value) {
    const attrs = this.attrs

    if (isString(prop)) {
      // 只能扩展 attrs 中已有的属性
      if (value && hasOwn(attrs, prop)) {
        // 更新单个配置信息
        attrs[prop] = value
        return this
      }

      // 只传递 prop 参数，则返回对应的属性值
      return attrs[prop]
    } else if (isObject(prop)) {
      // 批量更新配置信息
      extend(attrs, prop)

      return this
    } else if (arguments.length === 0) {
      // 不传递参数，直接返回整个
      return attrs
    }

    return this
  }

  render() {
    // 省略其它逻辑...
    return this
  }

  scrollTo(top, after) {
    // 省略其它逻辑...
    return this
  }

  destroy() {
    this.removeListeners()
    // 省略其它逻辑...
    return this
  }

  reload(options) {
    this.destroy().initialize(this.attrs(options))
    return this
  }
}

Anchors.DEFAULTS = {
  scrollElement: 'html,body',
  articleElement: '#article',
  selector: 'h1,h2,h3,h4,h5,h6',
  anchorURL: '',
  hasAnchor: true,
  isAtStart: true,
  showCode: false,
  created: null,
  mounted: null,
  afterScroll: null,
  beforeDestroy: null,
  afterDestroy: null
}

export default Anchors</code></pre></div></section><section class="section"><header class="section__header"><h3 class="section__h3">getScrollTotal(el)</h3></header><div class="section__content"><h4 class="section__h4">Description</h4><dl class="section__dl"><dt class="section__dt">Type：</dt><dd class="section__dd">Object</dd></dl><p>Anchors 模块：类似 AnchorJS 基础功能模块，自动分析段落层级。</p><pre class="section__pre"><code class="section__code">// 仅展示 API 中对外公开的方法和属性
class Anchors extends Base {
  constructor(options) {
    super()

    this.attrs = Anchors.DEFAULTS
    this.$articleElement = null
    this.$scrollElement = null
    this.$headings = []
    this.chapters = []

    // 省略其它逻辑...
  }

  getChapters(isTreeStructured = false) {
    const chapters = this.chapters
    return isTreeStructured ? toTree(chapters, 'id', 'pid') : chapters
  }

  count() {
    return this.chapters.length
  }

  attrs(prop, value) {
    const attrs = this.attrs

    if (isString(prop)) {
      // 只能扩展 attrs 中已有的属性
      if (value && hasOwn(attrs, prop)) {
        // 更新单个配置信息
        attrs[prop] = value
        return this
      }

      // 只传递 prop 参数，则返回对应的属性值
      return attrs[prop]
    } else if (isObject(prop)) {
      // 批量更新配置信息
      extend(attrs, prop)

      return this
    } else if (arguments.length === 0) {
      // 不传递参数，直接返回整个
      return attrs
    }

    return this
  }

  render() {
    // 省略其它逻辑...
    return this
  }

  scrollTo(top, after) {
    // 省略其它逻辑...
    return this
  }

  destroy() {
    this.removeListeners()
    // 省略其它逻辑...
    return this
  }

  reload(options) {
    this.destroy().initialize(this.attrs(options))
    return this
  }
}

Anchors.DEFAULTS = {
  scrollElement: 'html,body',
  articleElement: '#article',
  selector: 'h1,h2,h3,h4,h5,h6',
  anchorURL: '',
  hasAnchor: true,
  isAtStart: true,
  showCode: false,
  created: null,
  mounted: null,
  afterScroll: null,
  beforeDestroy: null,
  afterDestroy: null
}

export default Anchors</code></pre></div></section><section class="section"><header class="section__header"><h3 class="section__h3">getScrollTotalLeft(el)</h3></header><div class="section__content"><h4 class="section__h4">Description</h4><dl class="section__dl"><dt class="section__dt">Type：</dt><dd class="section__dd">Object</dd></dl><p>Anchors 模块：类似 AnchorJS 基础功能模块，自动分析段落层级。</p><pre class="section__pre"><code class="section__code">// 仅展示 API 中对外公开的方法和属性
class Anchors extends Base {
  constructor(options) {
    super()

    this.attrs = Anchors.DEFAULTS
    this.$articleElement = null
    this.$scrollElement = null
    this.$headings = []
    this.chapters = []

    // 省略其它逻辑...
  }

  getChapters(isTreeStructured = false) {
    const chapters = this.chapters
    return isTreeStructured ? toTree(chapters, 'id', 'pid') : chapters
  }

  count() {
    return this.chapters.length
  }

  attrs(prop, value) {
    const attrs = this.attrs

    if (isString(prop)) {
      // 只能扩展 attrs 中已有的属性
      if (value && hasOwn(attrs, prop)) {
        // 更新单个配置信息
        attrs[prop] = value
        return this
      }

      // 只传递 prop 参数，则返回对应的属性值
      return attrs[prop]
    } else if (isObject(prop)) {
      // 批量更新配置信息
      extend(attrs, prop)

      return this
    } else if (arguments.length === 0) {
      // 不传递参数，直接返回整个
      return attrs
    }

    return this
  }

  render() {
    // 省略其它逻辑...
    return this
  }

  scrollTo(top, after) {
    // 省略其它逻辑...
    return this
  }

  destroy() {
    this.removeListeners()
    // 省略其它逻辑...
    return this
  }

  reload(options) {
    this.destroy().initialize(this.attrs(options))
    return this
  }
}

Anchors.DEFAULTS = {
  scrollElement: 'html,body',
  articleElement: '#article',
  selector: 'h1,h2,h3,h4,h5,h6',
  anchorURL: '',
  hasAnchor: true,
  isAtStart: true,
  showCode: false,
  created: null,
  mounted: null,
  afterScroll: null,
  beforeDestroy: null,
  afterDestroy: null
}

export default Anchors</code></pre></div></section><section class="section"><header class="section__header"><h3 class="section__h3">getScrollTotalTop(el)</h3></header><div class="section__content"><h4 class="section__h4">Description</h4><dl class="section__dl"><dt class="section__dt">Type：</dt><dd class="section__dd">Object</dd></dl><p>Anchors 模块：类似 AnchorJS 基础功能模块，自动分析段落层级。</p><pre class="section__pre"><code class="section__code">// 仅展示 API 中对外公开的方法和属性
class Anchors extends Base {
  constructor(options) {
    super()

    this.attrs = Anchors.DEFAULTS
    this.$articleElement = null
    this.$scrollElement = null
    this.$headings = []
    this.chapters = []

    // 省略其它逻辑...
  }

  getChapters(isTreeStructured = false) {
    const chapters = this.chapters
    return isTreeStructured ? toTree(chapters, 'id', 'pid') : chapters
  }

  count() {
    return this.chapters.length
  }

  attrs(prop, value) {
    const attrs = this.attrs

    if (isString(prop)) {
      // 只能扩展 attrs 中已有的属性
      if (value && hasOwn(attrs, prop)) {
        // 更新单个配置信息
        attrs[prop] = value
        return this
      }

      // 只传递 prop 参数，则返回对应的属性值
      return attrs[prop]
    } else if (isObject(prop)) {
      // 批量更新配置信息
      extend(attrs, prop)

      return this
    } else if (arguments.length === 0) {
      // 不传递参数，直接返回整个
      return attrs
    }

    return this
  }

  render() {
    // 省略其它逻辑...
    return this
  }

  scrollTo(top, after) {
    // 省略其它逻辑...
    return this
  }

  destroy() {
    this.removeListeners()
    // 省略其它逻辑...
    return this
  }

  reload(options) {
    this.destroy().initialize(this.attrs(options))
    return this
  }
}

Anchors.DEFAULTS = {
  scrollElement: 'html,body',
  articleElement: '#article',
  selector: 'h1,h2,h3,h4,h5,h6',
  anchorURL: '',
  hasAnchor: true,
  isAtStart: true,
  showCode: false,
  created: null,
  mounted: null,
  afterScroll: null,
  beforeDestroy: null,
  afterDestroy: null
}

export default Anchors</code></pre></div></section><section class="section"><header class="section__header"><h3 class="section__h3">scrollTo(el, top[, afterStop])</h3></header><div class="section__content"><h4 class="section__h4">Description</h4><dl class="section__dl"><dt class="section__dt">Type：</dt><dd class="section__dd">Object</dd></dl><p>Anchors 模块：类似 AnchorJS 基础功能模块，自动分析段落层级。</p><pre class="section__pre"><code class="section__code">// 仅展示 API 中对外公开的方法和属性
class Anchors extends Base {
  constructor(options) {
    super()

    this.attrs = Anchors.DEFAULTS
    this.$articleElement = null
    this.$scrollElement = null
    this.$headings = []
    this.chapters = []

    // 省略其它逻辑...
  }

  getChapters(isTreeStructured = false) {
    const chapters = this.chapters
    return isTreeStructured ? toTree(chapters, 'id', 'pid') : chapters
  }

  count() {
    return this.chapters.length
  }

  attrs(prop, value) {
    const attrs = this.attrs

    if (isString(prop)) {
      // 只能扩展 attrs 中已有的属性
      if (value && hasOwn(attrs, prop)) {
        // 更新单个配置信息
        attrs[prop] = value
        return this
      }

      // 只传递 prop 参数，则返回对应的属性值
      return attrs[prop]
    } else if (isObject(prop)) {
      // 批量更新配置信息
      extend(attrs, prop)

      return this
    } else if (arguments.length === 0) {
      // 不传递参数，直接返回整个
      return attrs
    }

    return this
  }

  render() {
    // 省略其它逻辑...
    return this
  }

  scrollTo(top, after) {
    // 省略其它逻辑...
    return this
  }

  destroy() {
    this.removeListeners()
    // 省略其它逻辑...
    return this
  }

  reload(options) {
    this.destroy().initialize(this.attrs(options))
    return this
  }
}

Anchors.DEFAULTS = {
  scrollElement: 'html,body',
  articleElement: '#article',
  selector: 'h1,h2,h3,h4,h5,h6',
  anchorURL: '',
  hasAnchor: true,
  isAtStart: true,
  showCode: false,
  created: null,
  mounted: null,
  afterScroll: null,
  beforeDestroy: null,
  afterDestroy: null
}

export default Anchors</code></pre></div></section><section class="section"><header class="section__header"><h3 class="section__h3">offset(el)</h3></header><div class="section__content"><h4 class="section__h4">Description</h4><dl class="section__dl"><dt class="section__dt">Type：</dt><dd class="section__dd">Object</dd></dl><p>Anchors 模块：类似 AnchorJS 基础功能模块，自动分析段落层级。</p><pre class="section__pre"><code class="section__code">// 仅展示 API 中对外公开的方法和属性
class Anchors extends Base {
  constructor(options) {
    super()

    this.attrs = Anchors.DEFAULTS
    this.$articleElement = null
    this.$scrollElement = null
    this.$headings = []
    this.chapters = []

    // 省略其它逻辑...
  }

  getChapters(isTreeStructured = false) {
    const chapters = this.chapters
    return isTreeStructured ? toTree(chapters, 'id', 'pid') : chapters
  }

  count() {
    return this.chapters.length
  }

  attrs(prop, value) {
    const attrs = this.attrs

    if (isString(prop)) {
      // 只能扩展 attrs 中已有的属性
      if (value && hasOwn(attrs, prop)) {
        // 更新单个配置信息
        attrs[prop] = value
        return this
      }

      // 只传递 prop 参数，则返回对应的属性值
      return attrs[prop]
    } else if (isObject(prop)) {
      // 批量更新配置信息
      extend(attrs, prop)

      return this
    } else if (arguments.length === 0) {
      // 不传递参数，直接返回整个
      return attrs
    }

    return this
  }

  render() {
    // 省略其它逻辑...
    return this
  }

  scrollTo(top, after) {
    // 省略其它逻辑...
    return this
  }

  destroy() {
    this.removeListeners()
    // 省略其它逻辑...
    return this
  }

  reload(options) {
    this.destroy().initialize(this.attrs(options))
    return this
  }
}

Anchors.DEFAULTS = {
  scrollElement: 'html,body',
  articleElement: '#article',
  selector: 'h1,h2,h3,h4,h5,h6',
  anchorURL: '',
  hasAnchor: true,
  isAtStart: true,
  showCode: false,
  created: null,
  mounted: null,
  afterScroll: null,
  beforeDestroy: null,
  afterDestroy: null
}

export default Anchors</code></pre></div></section></section><section class="section"><header class="section__header"><h2 class="section__title">Selecting Siblings</h2></header><div class="section__content"><p>dom.js 提供以下几个方法用于获取邻居 DOM 元素。</p></div><section class="section"><header class="section__header"><h3 class="section__h3">getNextSibling(el)</h3></header><div class="section__content"><h4 class="section__h4">Description</h4><dl class="section__dl"><dt class="section__dt">Type：</dt><dd class="section__dd">Object</dd></dl><p>存储的是 Outline 对象当前使用中的配置选项：</p><p>说明：建议使用 attrs(prop) 方法来获取属性，避免直接调用属性。</p><pre class="section__pre"><code class="section__code">// 设置默认配置项
const outline = new Outline(Outline.DEFAULTS)

// 查看全部配置信息
outline.attrs</code></pre></div></section><section class="section"><header class="section__header"><h3 class="section__h3">getPrevSibling(el)</h3></header><div class="section__content"><h4 class="section__h4">Description</h4><dl class="section__dl"><dt class="section__dt">Type：</dt><dd class="section__dd">Object</dd></dl><p>Drawer 模块：独立的侧滑窗口模块。</p><pre class="section__pre"><code class="section__code">// 仅展示 API 中对外公开的方法和属性
class Drawer extends Base {
  constructor(options) {
    super()

    this.attrs = Drawer.DEFAULTS
    this.title = ''
    this.closed = true
    this.$el = null
    this.$modal = null
    this.$header = null
    this.$title = null
    this.$close = null
    this.$main = null
    this.$footer = null
    this.$overlay = null
    this.zIndex = 0

    // 省略其它逻辑...
  }

  isClosed() {
      return this.closed
  }

  setTitle() {
    this.attrs('title', title)
    this.title = title
    this.$title.innerHTML = title

    return this
  }

  attrs(prop, value) {
    // 省略其它逻辑...
    return this
  }

  render() {
    // 省略其它逻辑...
    return this
  }

  open() {
    // 省略其它逻辑...
    return this
  }

  close() {
    // 省略其它逻辑...
    return this
  }

  toggle() {
    // 省略其它逻辑...
    return this
  }

  destroy() {
    this.removeListeners()
    // 省略其它逻辑...
    return this
  }

  reload(options) {
    this.destroy().initialize(this.attrs(options))
    return this
  }
}

Drawer.DEFAULTS = {
   placement: 'rtl',
   title: '标题',
   size: 'regular',
   hasClose: true,
   hasOverlay: true,
   hasOffset: false,
   hasPadding: true,
   created: null,
   mounted: null,
   afterClosed: null,
   afterOpened: null,
   afterScroll: null,
   beforeDestroy: null,
   afterDestroy: null
}

export default Drawer</code></pre></div></section><section class="section"><header class="section__header"><h3 class="section__h3">getNextSiblings(el)</h3></header><div class="section__content"><h4 class="section__h4">Description</h4><dl class="section__dl"><dt class="section__dt">Type：</dt><dd class="section__dd">Array</dd></dl><p>存储的是 Outline 对象当前工具栏的完整的按钮配置信息：</p><pre class="section__pre"><code class="section__code">// 设置默认配置项
const outline = new Outline(Outline.DEFAULTS)

// 查看全部按钮配置信息
outline.buttons</code></pre></div></section><section class="section"><header class="section__header"><h3 class="section__h3">getPrevSiblings(el)</h3></header><div class="section__content"><h4 class="section__h4">Description</h4><dl class="section__dl"><dt class="section__dt">Type：</dt><dd class="section__dd">Object</dd></dl><p>Chapters 模块：独立的导航菜单模块；</p><pre class="section__pre"><code class="section__code">// 仅展示 API 中对外公开的方法和属性
class Chapters extends Base {
  constructor(options) {
    super()

    this.attrs = Chapters.DEFAULTS
    this.$el = null
    this.$title = null
    this.$main = null
    this.$list = null
    this.$placeholder = null
    this.$parentElement = null
    this.$scrollElement = null
    this.chapters = []
    this.closed = false
    this.active = 0
    this.getOffsetTop = 0
    this.$active = null
    this.timer = null
    this.playing = false

    // 省略其它逻辑...
  }

  isClosed() {
      return this.closed
  }

  isSticky() {
    const position = this.attrs('position')
    return position === 'sticky'
  }

  isFixed() {
    const position = this.attrs('position')
    return position === 'fixed'
  }

  isInside() {
    return this.isFixed() || this.isSticky()
  }

  isOutside() {
    return !this.isInside()
  }

  attrs(prop, value) {
    // 省略其它逻辑...
    return this
  }

  render() {
    // 省略其它逻辑...
    return this
  }

  highlight(id) {
    // 省略其它逻辑...
    return this
  }

  sticky() {
    // 省略其它逻辑...
    return this
  }

  scrollTo(top, after) {
    // 省略其它逻辑...
    return this
  }

  show() {
    // 省略其它逻辑...
    return this
  }

  hide() {
    // 省略其它逻辑...
    return this
  }

  toggle() {
    // 省略其它逻辑...
    return this
  }

  destroy() {
    this.removeListeners()
    // 省略其它逻辑...
    return this
  }

  reload(options) {
    this.destroy().initialize(this.attrs(options))
    return this
  }
}

Chapters.DEFAULTS = {
  parentElement: '',
  scrollElement: '',
  selector: '',
  active: 0,
  closed: false,
  showCode: true,
  position: 'relative',
  chapters: [],
  created: null,
  mounted: null,
  afterClosed: null,
  afterOpened: null,
  afterScroll: null,
  beforeDestroy: null,
  afterDestroy: null
}

export default Chapters</code></pre></div></section><section class="section"><header class="section__header"><h3 class="section__h3">getNextSiblingBy(el, filter)</h3></header><div class="section__content"><h4 class="section__h4">Description</h4><dl class="section__dl"><dt class="section__dt">Type：</dt><dd class="section__dd">Object</dd></dl><p>存储的是 Outline 对象当前使用中的配置选项：</p><p>说明：建议使用 attrs(prop) 方法来获取属性，避免直接调用属性。</p><pre class="section__pre"><code class="section__code">// 设置默认配置项
const outline = new Outline(Outline.DEFAULTS)

// 查看全部配置信息
outline.attrs</code></pre></div></section><section class="section"><header class="section__header"><h3 class="section__h3">getPrevSiblingBy(el, filter)</h3></header><div class="section__content"><h4 class="section__h4">Description</h4><dl class="section__dl"><dt class="section__dt">Type：</dt><dd class="section__dd">Object</dd></dl><p>Drawer 模块：独立的侧滑窗口模块。</p><pre class="section__pre"><code class="section__code">// 仅展示 API 中对外公开的方法和属性
class Drawer extends Base {
  constructor(options) {
    super()

    this.attrs = Drawer.DEFAULTS
    this.title = ''
    this.closed = true
    this.$el = null
    this.$modal = null
    this.$header = null
    this.$title = null
    this.$close = null
    this.$main = null
    this.$footer = null
    this.$overlay = null
    this.zIndex = 0

    // 省略其它逻辑...
  }

  isClosed() {
      return this.closed
  }

  setTitle() {
    this.attrs('title', title)
    this.title = title
    this.$title.innerHTML = title

    return this
  }

  attrs(prop, value) {
    // 省略其它逻辑...
    return this
  }

  render() {
    // 省略其它逻辑...
    return this
  }

  open() {
    // 省略其它逻辑...
    return this
  }

  close() {
    // 省略其它逻辑...
    return this
  }

  toggle() {
    // 省略其它逻辑...
    return this
  }

  destroy() {
    this.removeListeners()
    // 省略其它逻辑...
    return this
  }

  reload(options) {
    this.destroy().initialize(this.attrs(options))
    return this
  }
}

Drawer.DEFAULTS = {
   placement: 'rtl',
   title: '标题',
   size: 'regular',
   hasClose: true,
   hasOverlay: true,
   hasOffset: false,
   hasPadding: true,
   created: null,
   mounted: null,
   afterClosed: null,
   afterOpened: null,
   afterScroll: null,
   beforeDestroy: null,
   afterDestroy: null
}

export default Drawer</code></pre></div></section><section class="section"><header class="section__header"><h3 class="section__h3">getSiblings(el[, includeSelf = false])</h3></header><div class="section__content"><h4 class="section__h4">Description</h4><dl class="section__dl"><dt class="section__dt">Type：</dt><dd class="section__dd">Object</dd></dl><p>Chapters 模块：独立的导航菜单模块；</p><pre class="section__pre"><code class="section__code">// 仅展示 API 中对外公开的方法和属性
class Chapters extends Base {
  constructor(options) {
    super()

    this.attrs = Chapters.DEFAULTS
    this.$el = null
    this.$title = null
    this.$main = null
    this.$list = null
    this.$placeholder = null
    this.$parentElement = null
    this.$scrollElement = null
    this.chapters = []
    this.closed = false
    this.active = 0
    this.getOffsetTop = 0
    this.$active = null
    this.timer = null
    this.playing = false

    // 省略其它逻辑...
  }

  isClosed() {
      return this.closed
  }

  isSticky() {
    const position = this.attrs('position')
    return position === 'sticky'
  }

  isFixed() {
    const position = this.attrs('position')
    return position === 'fixed'
  }

  isInside() {
    return this.isFixed() || this.isSticky()
  }

  isOutside() {
    return !this.isInside()
  }

  attrs(prop, value) {
    // 省略其它逻辑...
    return this
  }

  render() {
    // 省略其它逻辑...
    return this
  }

  highlight(id) {
    // 省略其它逻辑...
    return this
  }

  sticky() {
    // 省略其它逻辑...
    return this
  }

  scrollTo(top, after) {
    // 省略其它逻辑...
    return this
  }

  show() {
    // 省略其它逻辑...
    return this
  }

  hide() {
    // 省略其它逻辑...
    return this
  }

  toggle() {
    // 省略其它逻辑...
    return this
  }

  destroy() {
    this.removeListeners()
    // 省略其它逻辑...
    return this
  }

  reload(options) {
    this.destroy().initialize(this.attrs(options))
    return this
  }
}

Chapters.DEFAULTS = {
  parentElement: '',
  scrollElement: '',
  selector: '',
  active: 0,
  closed: false,
  showCode: true,
  position: 'relative',
  chapters: [],
  created: null,
  mounted: null,
  afterClosed: null,
  afterOpened: null,
  afterScroll: null,
  beforeDestroy: null,
  afterDestroy: null
}

export default Chapters</code></pre></div></section><section class="section"><header class="section__header"><h3 class="section__h3">prev(el)</h3></header><div class="section__content"><h4 class="section__h4">Description</h4><dl class="section__dl"><dt class="section__dt">Type：</dt><dd class="section__dd">String</dd></dl><dl class="section__dl"><dt class="section__dt">Default：</dt><dd class="section__dd">'rtl'</dd></dl><p>可选，设置 position: relative 时，placement 定义侧滑菜单和 toolbar 导航位置：</p><ul><li>rtl - 菜单位置在窗口右侧，滑动动画为：right to left（默认值）；</li><li>ltr - 菜单位置在窗口左侧，滑动动画为：left to right；</li><li>ttb - 菜单位置在窗口上方，滑动动画为：top to bottom；</li><li>btt - 菜单位置在窗口下方，滑动动画为：bottom to top；</li></ul><pre class="section__pre"><code class="section__">// 默认是在窗口右侧显示侧滑导航菜单
new Outline(Outline.DEFAULTS)

// 调整为在窗口右侧显示侧滑导航菜单
new Outline({
  placement: 'ltr'
})</code></pre></div></section><section class="section"><header class="section__header"><h3 class="section__h3">next(el)</h3></header><div class="section__content"><h4 class="section__h4">Description</h4><dl class="section__dl"><dt class="section__dt">Type：</dt><dd class="section__dd">String</dd></dl><dl class="section__dl"><dt class="section__dt">Default：</dt><dd class="section__dd">''</dd></dl><p>可选，针对 API 文档类的文章页面，指定项目 git 仓库 issues 页面地址：</p><pre class="section__pre"><code class="section__code">const outline = new Outline(Outline.DEFAULTS)

// 侧边栏的 Toolbar 会多出一个 issues 图标的按钮
outline.reload({
  issues: 'https://github.com/yaohaixiao/outline.js/issues'
})</code></pre></div></section><section class="section"><header class="section__header"><h3 class="section__h3">prevAll(el)</h3></header><div class="section__content"><h4 class="section__h4">Description</h4><dl class="section__dl"><dt class="section__dt">Type：</dt><dd class="section__dd">String</dd></dl><dl class="section__dl"><dt class="section__dt">Default：</dt><dd class="section__dd">'relative'</dd></dl><p>可选，用来指定文章导读导航菜单的显示位置：</p><ul><li>relative: （默认值）创建独立的侧滑菜单；</li><li>sticky: 导航菜单将以 sticky 模式布局（需要确保菜单插入位置(DOM 节点)支持 sticky 模式布局）；</li><li>fixed: 导航菜单将模拟 sticky 布局，起初是普通定位，会自动监听滚动位置，但滚动到导航菜单顶部时，以 fixed 模式布局，模拟 sticky 布局效果；</li></ul><p>当设置为 sticky 和 fixed 布局时，需要设置 parentElement。</p><p>注意：2.0.0 暂时不支持之前版本那种 inside 模式，不会自动在文章开始位置插入 chapters 导航菜单</p><pre class="section__pre"><code class="section__code">// 默认生成独立的侧滑弹窗导航菜单
new Outline(Outline.DEFAULTS)

// 在页面内部插入导航菜单
new Outline({
  // 在（文章的）侧边栏显示导航菜单
  parentElement: '#aside',
  // 或者 sticky 定位
  position: 'fixed'
})</code></pre></div></section><section class="section"><header class="section__header"><h3 class="section__h3">nextAll(el)</h3></header><div class="section__content"><h4 class="section__h4">Description</h4><dl class="section__dl"><dt class="section__dt">Type：</dt><dd class="section__dd">String</dd></dl><dl class="section__dl"><dt class="section__dt">Default：</dt><dd class="section__dd">'#aside'</dd></dl><ul><li>String： 选择器字符串，默认值：html,body（即 window 窗口）;</li><li>HTMLElement： DOM 元素;</li></ul><p>可选，导航菜单将要插入的位置（DOM 元素）。仅在 position 设置为 sticky 和 fixed 布局时有效。</p><pre class="section__pre"><code class="section__code">// 在页面内部插入导航菜单
new Outline({
  // 在（文章的）侧边栏显示导航菜单
  parentElement: '#aside',
  // 或者 sticky 定位
  position: 'fixed'
})</code></pre></div></section><section class="section"><header class="section__header"><h3 class="section__h3">siblings(el[, includeSelf = false])</h3></header><div class="section__content"><h4 class="section__h4">Description</h4><dl class="section__dl"><dt class="section__dt">Type：</dt><dd class="section__dd">Object</dd></dl><p>Anchors 模块：类似 AnchorJS 基础功能模块，自动分析段落层级。</p><pre class="section__pre"><code class="section__code">// 仅展示 API 中对外公开的方法和属性
class Anchors extends Base {
  constructor(options) {
    super()

    this.attrs = Anchors.DEFAULTS
    this.$articleElement = null
    this.$scrollElement = null
    this.$headings = []
    this.chapters = []

    // 省略其它逻辑...
  }

  getChapters(isTreeStructured = false) {
    const chapters = this.chapters
    return isTreeStructured ? toTree(chapters, 'id', 'pid') : chapters
  }

  count() {
    return this.chapters.length
  }

  attrs(prop, value) {
    const attrs = this.attrs

    if (isString(prop)) {
      // 只能扩展 attrs 中已有的属性
      if (value && hasOwn(attrs, prop)) {
        // 更新单个配置信息
        attrs[prop] = value
        return this
      }

      // 只传递 prop 参数，则返回对应的属性值
      return attrs[prop]
    } else if (isObject(prop)) {
      // 批量更新配置信息
      extend(attrs, prop)

      return this
    } else if (arguments.length === 0) {
      // 不传递参数，直接返回整个
      return attrs
    }

    return this
  }

  render() {
    // 省略其它逻辑...
    return this
  }

  scrollTo(top, after) {
    // 省略其它逻辑...
    return this
  }

  destroy() {
    this.removeListeners()
    // 省略其它逻辑...
    return this
  }

  reload(options) {
    this.destroy().initialize(this.attrs(options))
    return this
  }
}

Anchors.DEFAULTS = {
  scrollElement: 'html,body',
  articleElement: '#article',
  selector: 'h1,h2,h3,h4,h5,h6',
  anchorURL: '',
  hasAnchor: true,
  isAtStart: true,
  showCode: false,
  created: null,
  mounted: null,
  afterScroll: null,
  beforeDestroy: null,
  afterDestroy: null
}

export default Anchors</code></pre></div></section></section><section class="section"><header class="section__header"><h2 class="section__title">Size</h2></header><div class="section__content"><p>dom.js 提供以下几个方法用于获取 DOM 元素的尺寸大小。</p></div><section class="section"><header class="section__header"><h3 class="section__h3">getDocumentHeight()</h3></header><div class="section__content"><h4 class="section__h4">Description</h4><dl class="section__dl"><dt class="section__dt">Type：</dt><dd class="section__dd">Object</dd></dl><p>Anchors 模块：类似 AnchorJS 基础功能模块，自动分析段落层级。</p><pre class="section__pre"><code class="section__code">// 仅展示 API 中对外公开的方法和属性
class Anchors extends Base {
  constructor(options) {
    super()

    this.attrs = Anchors.DEFAULTS
    this.$articleElement = null
    this.$scrollElement = null
    this.$headings = []
    this.chapters = []

    // 省略其它逻辑...
  }

  getChapters(isTreeStructured = false) {
    const chapters = this.chapters
    return isTreeStructured ? toTree(chapters, 'id', 'pid') : chapters
  }

  count() {
    return this.chapters.length
  }

  attrs(prop, value) {
    const attrs = this.attrs

    if (isString(prop)) {
      // 只能扩展 attrs 中已有的属性
      if (value && hasOwn(attrs, prop)) {
        // 更新单个配置信息
        attrs[prop] = value
        return this
      }

      // 只传递 prop 参数，则返回对应的属性值
      return attrs[prop]
    } else if (isObject(prop)) {
      // 批量更新配置信息
      extend(attrs, prop)

      return this
    } else if (arguments.length === 0) {
      // 不传递参数，直接返回整个
      return attrs
    }

    return this
  }

  render() {
    // 省略其它逻辑...
    return this
  }

  scrollTo(top, after) {
    // 省略其它逻辑...
    return this
  }

  destroy() {
    this.removeListeners()
    // 省略其它逻辑...
    return this
  }

  reload(options) {
    this.destroy().initialize(this.attrs(options))
    return this
  }
}

Anchors.DEFAULTS = {
  scrollElement: 'html,body',
  articleElement: '#article',
  selector: 'h1,h2,h3,h4,h5,h6',
  anchorURL: '',
  hasAnchor: true,
  isAtStart: true,
  showCode: false,
  created: null,
  mounted: null,
  afterScroll: null,
  beforeDestroy: null,
  afterDestroy: null
}

export default Anchors</code></pre></div></section><section class="section"><header class="section__header"><h3 class="section__h3">getDocumentHeight()</h3></header><div class="section__content"><h4 class="section__h4">Description</h4><dl class="section__dl"><dt class="section__dt">Type：</dt><dd class="section__dd">Object</dd></dl><p>Anchors 模块：类似 AnchorJS 基础功能模块，自动分析段落层级。</p><pre class="section__pre"><code class="section__code">// 仅展示 API 中对外公开的方法和属性
class Anchors extends Base {
  constructor(options) {
    super()

    this.attrs = Anchors.DEFAULTS
    this.$articleElement = null
    this.$scrollElement = null
    this.$headings = []
    this.chapters = []

    // 省略其它逻辑...
  }

  getChapters(isTreeStructured = false) {
    const chapters = this.chapters
    return isTreeStructured ? toTree(chapters, 'id', 'pid') : chapters
  }

  count() {
    return this.chapters.length
  }

  attrs(prop, value) {
    const attrs = this.attrs

    if (isString(prop)) {
      // 只能扩展 attrs 中已有的属性
      if (value && hasOwn(attrs, prop)) {
        // 更新单个配置信息
        attrs[prop] = value
        return this
      }

      // 只传递 prop 参数，则返回对应的属性值
      return attrs[prop]
    } else if (isObject(prop)) {
      // 批量更新配置信息
      extend(attrs, prop)

      return this
    } else if (arguments.length === 0) {
      // 不传递参数，直接返回整个
      return attrs
    }

    return this
  }

  render() {
    // 省略其它逻辑...
    return this
  }

  scrollTo(top, after) {
    // 省略其它逻辑...
    return this
  }

  destroy() {
    this.removeListeners()
    // 省略其它逻辑...
    return this
  }

  reload(options) {
    this.destroy().initialize(this.attrs(options))
    return this
  }
}

Anchors.DEFAULTS = {
  scrollElement: 'html,body',
  articleElement: '#article',
  selector: 'h1,h2,h3,h4,h5,h6',
  anchorURL: '',
  hasAnchor: true,
  isAtStart: true,
  showCode: false,
  created: null,
  mounted: null,
  afterScroll: null,
  beforeDestroy: null,
  afterDestroy: null
}

export default Anchors</code></pre></div></section><section class="section"><header class="section__header"><h3 class="section__h3">getViewportHeight()</h3></header><div class="section__content"><h4 class="section__h4">Description</h4><dl class="section__dl"><dt class="section__dt">Type：</dt><dd class="section__dd">Object</dd></dl><p>Anchors 模块：类似 AnchorJS 基础功能模块，自动分析段落层级。</p><pre class="section__pre"><code class="section__code">// 仅展示 API 中对外公开的方法和属性
class Anchors extends Base {
  constructor(options) {
    super()

    this.attrs = Anchors.DEFAULTS
    this.$articleElement = null
    this.$scrollElement = null
    this.$headings = []
    this.chapters = []

    // 省略其它逻辑...
  }

  getChapters(isTreeStructured = false) {
    const chapters = this.chapters
    return isTreeStructured ? toTree(chapters, 'id', 'pid') : chapters
  }

  count() {
    return this.chapters.length
  }

  attrs(prop, value) {
    const attrs = this.attrs

    if (isString(prop)) {
      // 只能扩展 attrs 中已有的属性
      if (value && hasOwn(attrs, prop)) {
        // 更新单个配置信息
        attrs[prop] = value
        return this
      }

      // 只传递 prop 参数，则返回对应的属性值
      return attrs[prop]
    } else if (isObject(prop)) {
      // 批量更新配置信息
      extend(attrs, prop)

      return this
    } else if (arguments.length === 0) {
      // 不传递参数，直接返回整个
      return attrs
    }

    return this
  }

  render() {
    // 省略其它逻辑...
    return this
  }

  scrollTo(top, after) {
    // 省略其它逻辑...
    return this
  }

  destroy() {
    this.removeListeners()
    // 省略其它逻辑...
    return this
  }

  reload(options) {
    this.destroy().initialize(this.attrs(options))
    return this
  }
}

Anchors.DEFAULTS = {
  scrollElement: 'html,body',
  articleElement: '#article',
  selector: 'h1,h2,h3,h4,h5,h6',
  anchorURL: '',
  hasAnchor: true,
  isAtStart: true,
  showCode: false,
  created: null,
  mounted: null,
  afterScroll: null,
  beforeDestroy: null,
  afterDestroy: null
}

export default Anchors</code></pre></div></section><section class="section"><header class="section__header"><h3 class="section__h3">getViewportWidth()</h3></header><div class="section__content"><h4 class="section__h4">Description</h4><dl class="section__dl"><dt class="section__dt">Type：</dt><dd class="section__dd">Object</dd></dl><p>Anchors 模块：类似 AnchorJS 基础功能模块，自动分析段落层级。</p><pre class="section__pre"><code class="section__code">// 仅展示 API 中对外公开的方法和属性
class Anchors extends Base {
  constructor(options) {
    super()

    this.attrs = Anchors.DEFAULTS
    this.$articleElement = null
    this.$scrollElement = null
    this.$headings = []
    this.chapters = []

    // 省略其它逻辑...
  }

  getChapters(isTreeStructured = false) {
    const chapters = this.chapters
    return isTreeStructured ? toTree(chapters, 'id', 'pid') : chapters
  }

  count() {
    return this.chapters.length
  }

  attrs(prop, value) {
    const attrs = this.attrs

    if (isString(prop)) {
      // 只能扩展 attrs 中已有的属性
      if (value && hasOwn(attrs, prop)) {
        // 更新单个配置信息
        attrs[prop] = value
        return this
      }

      // 只传递 prop 参数，则返回对应的属性值
      return attrs[prop]
    } else if (isObject(prop)) {
      // 批量更新配置信息
      extend(attrs, prop)

      return this
    } else if (arguments.length === 0) {
      // 不传递参数，直接返回整个
      return attrs
    }

    return this
  }

  render() {
    // 省略其它逻辑...
    return this
  }

  scrollTo(top, after) {
    // 省略其它逻辑...
    return this
  }

  destroy() {
    this.removeListeners()
    // 省略其它逻辑...
    return this
  }

  reload(options) {
    this.destroy().initialize(this.attrs(options))
    return this
  }
}

Anchors.DEFAULTS = {
  scrollElement: 'html,body',
  articleElement: '#article',
  selector: 'h1,h2,h3,h4,h5,h6',
  anchorURL: '',
  hasAnchor: true,
  isAtStart: true,
  showCode: false,
  created: null,
  mounted: null,
  afterScroll: null,
  beforeDestroy: null,
  afterDestroy: null
}

export default Anchors</code></pre></div></section><section class="section"><header class="section__header"><h3 class="section__h3">getElementSizes(el)</h3></header><div class="section__content"><h4 class="section__h4">Description</h4><dl class="section__dl"><dt class="section__dt">Type：</dt><dd class="section__dd">Object</dd></dl><p>Anchors 模块：类似 AnchorJS 基础功能模块，自动分析段落层级。</p><pre class="section__pre"><code class="section__code">// 仅展示 API 中对外公开的方法和属性
class Anchors extends Base {
  constructor(options) {
    super()

    this.attrs = Anchors.DEFAULTS
    this.$articleElement = null
    this.$scrollElement = null
    this.$headings = []
    this.chapters = []

    // 省略其它逻辑...
  }

  getChapters(isTreeStructured = false) {
    const chapters = this.chapters
    return isTreeStructured ? toTree(chapters, 'id', 'pid') : chapters
  }

  count() {
    return this.chapters.length
  }

  attrs(prop, value) {
    const attrs = this.attrs

    if (isString(prop)) {
      // 只能扩展 attrs 中已有的属性
      if (value && hasOwn(attrs, prop)) {
        // 更新单个配置信息
        attrs[prop] = value
        return this
      }

      // 只传递 prop 参数，则返回对应的属性值
      return attrs[prop]
    } else if (isObject(prop)) {
      // 批量更新配置信息
      extend(attrs, prop)

      return this
    } else if (arguments.length === 0) {
      // 不传递参数，直接返回整个
      return attrs
    }

    return this
  }

  render() {
    // 省略其它逻辑...
    return this
  }

  scrollTo(top, after) {
    // 省略其它逻辑...
    return this
  }

  destroy() {
    this.removeListeners()
    // 省略其它逻辑...
    return this
  }

  reload(options) {
    this.destroy().initialize(this.attrs(options))
    return this
  }
}

Anchors.DEFAULTS = {
  scrollElement: 'html,body',
  articleElement: '#article',
  selector: 'h1,h2,h3,h4,h5,h6',
  anchorURL: '',
  hasAnchor: true,
  isAtStart: true,
  showCode: false,
  created: null,
  mounted: null,
  afterScroll: null,
  beforeDestroy: null,
  afterDestroy: null
}

export default Anchors</code></pre></div></section><section class="section"><header class="section__header"><h3 class="section__h3">innerHeight(el)</h3></header><div class="section__content"><h4 class="section__h4">Description</h4><dl class="section__dl"><dt class="section__dt">Type：</dt><dd class="section__dd">Object</dd></dl><p>Anchors 模块：类似 AnchorJS 基础功能模块，自动分析段落层级。</p><pre class="section__pre"><code class="section__code">// 仅展示 API 中对外公开的方法和属性
class Anchors extends Base {
  constructor(options) {
    super()

    this.attrs = Anchors.DEFAULTS
    this.$articleElement = null
    this.$scrollElement = null
    this.$headings = []
    this.chapters = []

    // 省略其它逻辑...
  }

  getChapters(isTreeStructured = false) {
    const chapters = this.chapters
    return isTreeStructured ? toTree(chapters, 'id', 'pid') : chapters
  }

  count() {
    return this.chapters.length
  }

  attrs(prop, value) {
    const attrs = this.attrs

    if (isString(prop)) {
      // 只能扩展 attrs 中已有的属性
      if (value && hasOwn(attrs, prop)) {
        // 更新单个配置信息
        attrs[prop] = value
        return this
      }

      // 只传递 prop 参数，则返回对应的属性值
      return attrs[prop]
    } else if (isObject(prop)) {
      // 批量更新配置信息
      extend(attrs, prop)

      return this
    } else if (arguments.length === 0) {
      // 不传递参数，直接返回整个
      return attrs
    }

    return this
  }

  render() {
    // 省略其它逻辑...
    return this
  }

  scrollTo(top, after) {
    // 省略其它逻辑...
    return this
  }

  destroy() {
    this.removeListeners()
    // 省略其它逻辑...
    return this
  }

  reload(options) {
    this.destroy().initialize(this.attrs(options))
    return this
  }
}

Anchors.DEFAULTS = {
  scrollElement: 'html,body',
  articleElement: '#article',
  selector: 'h1,h2,h3,h4,h5,h6',
  anchorURL: '',
  hasAnchor: true,
  isAtStart: true,
  showCode: false,
  created: null,
  mounted: null,
  afterScroll: null,
  beforeDestroy: null,
  afterDestroy: null
}

export default Anchors</code></pre></div></section><section class="section"><header class="section__header"><h3 class="section__h3">innerWidth(el)</h3></header><div class="section__content"><h4 class="section__h4">Description</h4><dl class="section__dl"><dt class="section__dt">Type：</dt><dd class="section__dd">Object</dd></dl><p>Anchors 模块：类似 AnchorJS 基础功能模块，自动分析段落层级。</p><pre class="section__pre"><code class="section__code">// 仅展示 API 中对外公开的方法和属性
class Anchors extends Base {
  constructor(options) {
    super()

    this.attrs = Anchors.DEFAULTS
    this.$articleElement = null
    this.$scrollElement = null
    this.$headings = []
    this.chapters = []

    // 省略其它逻辑...
  }

  getChapters(isTreeStructured = false) {
    const chapters = this.chapters
    return isTreeStructured ? toTree(chapters, 'id', 'pid') : chapters
  }

  count() {
    return this.chapters.length
  }

  attrs(prop, value) {
    const attrs = this.attrs

    if (isString(prop)) {
      // 只能扩展 attrs 中已有的属性
      if (value && hasOwn(attrs, prop)) {
        // 更新单个配置信息
        attrs[prop] = value
        return this
      }

      // 只传递 prop 参数，则返回对应的属性值
      return attrs[prop]
    } else if (isObject(prop)) {
      // 批量更新配置信息
      extend(attrs, prop)

      return this
    } else if (arguments.length === 0) {
      // 不传递参数，直接返回整个
      return attrs
    }

    return this
  }

  render() {
    // 省略其它逻辑...
    return this
  }

  scrollTo(top, after) {
    // 省略其它逻辑...
    return this
  }

  destroy() {
    this.removeListeners()
    // 省略其它逻辑...
    return this
  }

  reload(options) {
    this.destroy().initialize(this.attrs(options))
    return this
  }
}

Anchors.DEFAULTS = {
  scrollElement: 'html,body',
  articleElement: '#article',
  selector: 'h1,h2,h3,h4,h5,h6',
  anchorURL: '',
  hasAnchor: true,
  isAtStart: true,
  showCode: false,
  created: null,
  mounted: null,
  afterScroll: null,
  beforeDestroy: null,
  afterDestroy: null
}

export default Anchors</code></pre></div></section><section class="section"><header class="section__header"><h3 class="section__h3">outerHeight(el)</h3></header><div class="section__content"><h4 class="section__h4">Description</h4><dl class="section__dl"><dt class="section__dt">Type：</dt><dd class="section__dd">Object</dd></dl><p>Anchors 模块：类似 AnchorJS 基础功能模块，自动分析段落层级。</p><pre class="section__pre"><code class="section__code">// 仅展示 API 中对外公开的方法和属性
class Anchors extends Base {
  constructor(options) {
    super()

    this.attrs = Anchors.DEFAULTS
    this.$articleElement = null
    this.$scrollElement = null
    this.$headings = []
    this.chapters = []

    // 省略其它逻辑...
  }

  getChapters(isTreeStructured = false) {
    const chapters = this.chapters
    return isTreeStructured ? toTree(chapters, 'id', 'pid') : chapters
  }

  count() {
    return this.chapters.length
  }

  attrs(prop, value) {
    const attrs = this.attrs

    if (isString(prop)) {
      // 只能扩展 attrs 中已有的属性
      if (value && hasOwn(attrs, prop)) {
        // 更新单个配置信息
        attrs[prop] = value
        return this
      }

      // 只传递 prop 参数，则返回对应的属性值
      return attrs[prop]
    } else if (isObject(prop)) {
      // 批量更新配置信息
      extend(attrs, prop)

      return this
    } else if (arguments.length === 0) {
      // 不传递参数，直接返回整个
      return attrs
    }

    return this
  }

  render() {
    // 省略其它逻辑...
    return this
  }

  scrollTo(top, after) {
    // 省略其它逻辑...
    return this
  }

  destroy() {
    this.removeListeners()
    // 省略其它逻辑...
    return this
  }

  reload(options) {
    this.destroy().initialize(this.attrs(options))
    return this
  }
}

Anchors.DEFAULTS = {
  scrollElement: 'html,body',
  articleElement: '#article',
  selector: 'h1,h2,h3,h4,h5,h6',
  anchorURL: '',
  hasAnchor: true,
  isAtStart: true,
  showCode: false,
  created: null,
  mounted: null,
  afterScroll: null,
  beforeDestroy: null,
  afterDestroy: null
}

export default Anchors</code></pre></div></section><section class="section"><header class="section__header"><h3 class="section__h3">outerWidth(el)</h3></header><div class="section__content"><h4 class="section__h4">Description</h4><dl class="section__dl"><dt class="section__dt">Type：</dt><dd class="section__dd">Object</dd></dl><p>Anchors 模块：类似 AnchorJS 基础功能模块，自动分析段落层级。</p><pre class="section__pre"><code class="section__code">// 仅展示 API 中对外公开的方法和属性
class Anchors extends Base {
  constructor(options) {
    super()

    this.attrs = Anchors.DEFAULTS
    this.$articleElement = null
    this.$scrollElement = null
    this.$headings = []
    this.chapters = []

    // 省略其它逻辑...
  }

  getChapters(isTreeStructured = false) {
    const chapters = this.chapters
    return isTreeStructured ? toTree(chapters, 'id', 'pid') : chapters
  }

  count() {
    return this.chapters.length
  }

  attrs(prop, value) {
    const attrs = this.attrs

    if (isString(prop)) {
      // 只能扩展 attrs 中已有的属性
      if (value && hasOwn(attrs, prop)) {
        // 更新单个配置信息
        attrs[prop] = value
        return this
      }

      // 只传递 prop 参数，则返回对应的属性值
      return attrs[prop]
    } else if (isObject(prop)) {
      // 批量更新配置信息
      extend(attrs, prop)

      return this
    } else if (arguments.length === 0) {
      // 不传递参数，直接返回整个
      return attrs
    }

    return this
  }

  render() {
    // 省略其它逻辑...
    return this
  }

  scrollTo(top, after) {
    // 省略其它逻辑...
    return this
  }

  destroy() {
    this.removeListeners()
    // 省略其它逻辑...
    return this
  }

  reload(options) {
    this.destroy().initialize(this.attrs(options))
    return this
  }
}

Anchors.DEFAULTS = {
  scrollElement: 'html,body',
  articleElement: '#article',
  selector: 'h1,h2,h3,h4,h5,h6',
  anchorURL: '',
  hasAnchor: true,
  isAtStart: true,
  showCode: false,
  created: null,
  mounted: null,
  afterScroll: null,
  beforeDestroy: null,
  afterDestroy: null
}

export default Anchors</code></pre></div></section><section class="section"><header class="section__header"><h3 class="section__h3">height(el, val)</h3></header><div class="section__content"><h4 class="section__h4">Description</h4><dl class="section__dl"><dt class="section__dt">Type：</dt><dd class="section__dd">Object</dd></dl><p>Anchors 模块：类似 AnchorJS 基础功能模块，自动分析段落层级。</p><pre class="section__pre"><code class="section__code">// 仅展示 API 中对外公开的方法和属性
class Anchors extends Base {
  constructor(options) {
    super()

    this.attrs = Anchors.DEFAULTS
    this.$articleElement = null
    this.$scrollElement = null
    this.$headings = []
    this.chapters = []

    // 省略其它逻辑...
  }

  getChapters(isTreeStructured = false) {
    const chapters = this.chapters
    return isTreeStructured ? toTree(chapters, 'id', 'pid') : chapters
  }

  count() {
    return this.chapters.length
  }

  attrs(prop, value) {
    const attrs = this.attrs

    if (isString(prop)) {
      // 只能扩展 attrs 中已有的属性
      if (value && hasOwn(attrs, prop)) {
        // 更新单个配置信息
        attrs[prop] = value
        return this
      }

      // 只传递 prop 参数，则返回对应的属性值
      return attrs[prop]
    } else if (isObject(prop)) {
      // 批量更新配置信息
      extend(attrs, prop)

      return this
    } else if (arguments.length === 0) {
      // 不传递参数，直接返回整个
      return attrs
    }

    return this
  }

  render() {
    // 省略其它逻辑...
    return this
  }

  scrollTo(top, after) {
    // 省略其它逻辑...
    return this
  }

  destroy() {
    this.removeListeners()
    // 省略其它逻辑...
    return this
  }

  reload(options) {
    this.destroy().initialize(this.attrs(options))
    return this
  }
}

Anchors.DEFAULTS = {
  scrollElement: 'html,body',
  articleElement: '#article',
  selector: 'h1,h2,h3,h4,h5,h6',
  anchorURL: '',
  hasAnchor: true,
  isAtStart: true,
  showCode: false,
  created: null,
  mounted: null,
  afterScroll: null,
  beforeDestroy: null,
  afterDestroy: null
}

export default Anchors</code></pre></div></section><section class="section"><header class="section__header"><h3 class="section__h3">width(el, val)</h3></header><div class="section__content"><h4 class="section__h4">Description</h4><dl class="section__dl"><dt class="section__dt">Type：</dt><dd class="section__dd">Object</dd></dl><p>Anchors 模块：类似 AnchorJS 基础功能模块，自动分析段落层级。</p><pre class="section__pre"><code class="section__code">// 仅展示 API 中对外公开的方法和属性
class Anchors extends Base {
  constructor(options) {
    super()

    this.attrs = Anchors.DEFAULTS
    this.$articleElement = null
    this.$scrollElement = null
    this.$headings = []
    this.chapters = []

    // 省略其它逻辑...
  }

  getChapters(isTreeStructured = false) {
    const chapters = this.chapters
    return isTreeStructured ? toTree(chapters, 'id', 'pid') : chapters
  }

  count() {
    return this.chapters.length
  }

  attrs(prop, value) {
    const attrs = this.attrs

    if (isString(prop)) {
      // 只能扩展 attrs 中已有的属性
      if (value && hasOwn(attrs, prop)) {
        // 更新单个配置信息
        attrs[prop] = value
        return this
      }

      // 只传递 prop 参数，则返回对应的属性值
      return attrs[prop]
    } else if (isObject(prop)) {
      // 批量更新配置信息
      extend(attrs, prop)

      return this
    } else if (arguments.length === 0) {
      // 不传递参数，直接返回整个
      return attrs
    }

    return this
  }

  render() {
    // 省略其它逻辑...
    return this
  }

  scrollTo(top, after) {
    // 省略其它逻辑...
    return this
  }

  destroy() {
    this.removeListeners()
    // 省略其它逻辑...
    return this
  }

  reload(options) {
    this.destroy().initialize(this.attrs(options))
    return this
  }
}

Anchors.DEFAULTS = {
  scrollElement: 'html,body',
  articleElement: '#article',
  selector: 'h1,h2,h3,h4,h5,h6',
  anchorURL: '',
  hasAnchor: true,
  isAtStart: true,
  showCode: false,
  created: null,
  mounted: null,
  afterScroll: null,
  beforeDestroy: null,
  afterDestroy: null
}

export default Anchors</code></pre></div></section></section><section class="section"><header class="section__header"><h2 class="section__title">Style</h2></header><div class="section__content"><p>dom.js 提供以下几个方法用以获取或者设置 DOM 元素的 css 样式属性：</p></div><section class="section"><header class="section__header"><h3 class="section__h3">getStyle(el, attr)</h3></header><div class="section__content"><h4 class="section__h4">Description</h4><p>getStyle() 用来获取 DOM 元素的某个 CSS 样式值。</p><dl class="section__dl"><dt class="section__dt">Category：</dt><dd class="section__dd">Style</dd></dl><h4 class="section__h4">Parameters</h4><h5 class="section__h4">el</h5><dl class="section__dl"><dt class="section__dt">Type：</dt><dd class="section__dd">HTMLElement</dd></dl><p>（必须）el 参数指定 DOM 元素。</p><h5 class="section__h4">token</h5><dl class="section__dl"><dt class="section__dt">Type：</dt><dd class="section__dd">String</dd></dl><p>（必须）指定 CSS 属性名称。</p><h4 class="section__h4">Returns</h4><dl class="section__dl"><dt class="section__dt">Type：</dt><dd class="section__dd">String</dd></dl><p>返回指定的 attr 的属性值。</p><pre class="section__pre"><code class="section__code">&lt;ul id="list" class="list"&gt;
    &lt;li class="item active"&gt;Home&lt;/li&gt;
    &lt;li class="item"&gt;Blog&lt;/li&gt;
    &lt;li class="item"&gt;Projects&lt;/li&gt;
    &lt;li class="item"&gt;About&lt;/li&gt;
&lt;/ul&gt;

// 引入 DOM 模块（中的所有工具方法）
import DOM from '@yaohaixiao/dom.js/dom
// 引用 setStyle 单个方法
import setStyle from '@yaohaixiao/dom.js/setStyle'

const $list = DOM.byId('#list')

DOM.setStyle($list, 'display', 'none')
DOM.setStyle($list, 'display', 'block')

setStyle($list, 'background-color', '#f2f2f2')

DOM.getStyle($list, 'background-color') // -> '#f2f2f2'
getStyle($list, 'display') // -> 'block'</code></pre></div></section><section class="section"><header class="section__header"><h3 class="section__h3">setStyle(el, attr, val)</h3></header><div class="section__content"><p>setStyle() 方法用来给 DOM 元素添加 CSS 样式。</p><dl class="section__dl"><dt class="section__dt">Category：</dt><dd class="section__dd">Style</dd></dl><h4 class="section__h4">Parameters</h4><h5 class="section__h4">el</h5><dl class="section__dl"><dt class="section__dt">Type：</dt><dd class="section__dd">HTMLElement</dd></dl><p>（必须）主题名称。</p><h5 class="section__h4">attr</h5><dl class="section__dl"><dt class="section__dt">Type：</dt><dd class="section__dd">String</dd></dl><p>（必须）属性名称。</p><h5 class="section__h4">val<dl class="section__dl"><dt class="section__dt">Type：</dt><dd class="section__dd">String</dd></dl><p>（必须）属性值。</p></h5><pre class="section__pre"><code class="section__code">&lt;ul id="list" class="list"&gt;
    &lt;li class="item active"&gt;Home&lt;/li&gt;
    &lt;li class="item"&gt;Blog&lt;/li&gt;
    &lt;li class="item"&gt;Projects&lt;/li&gt;
    &lt;li class="item"&gt;About&lt;/li&gt;
&lt;/ul&gt;

// 引入 DOM 模块（中的所有工具方法）
import DOM from '@yaohaixiao/dom.js/dom
// 引用 addClass 单个方法
import setStyle from '@yaohaixiao/dom.js/setStyle'

const $list = DOM.byId('#list')

DOM.setStyle($list, 'display', 'none')
DOM.setStyle($list, 'display', 'block')

setStyle($list, 'background-color', '#f2f2f2')</code></pre></div></section><section class="section"><header class="section__header"><h3 class="section__h3">getStyles(el, attrs)</h3></header><div class="section__content"><h4 class="section__h4">Description</h4><p>getStyles() 方法用来设置或者获取初始化时配置的 attrs 信息的。</p><h4 class="section__h4">Parameters</h4><h5 class="section__h4">prop</h5><dl class="section__dl"><dt class="section__dt">Type：</dt><dd class="section__dd">String|HTMLElement</dd></dl><p>（可选）options 中的属性名称或者要配置的 attrs 信息。</p><h5 class="section__h4">value</h5><dl class="section__dl"><dt class="section__dt">Type：</dt><dd class="section__dd">Any</dd></dl><p>（可选）要设置的 prop 属性的值</p><ul><li>不传递任何参数：返回完整的 attrs 配置信息；</li><li>仅传递 prop：</li><ul><li>String: 返回 attrs 配型信息中与 prop 对应的值；</li><li>Object: 用来设置 attrs 配置信息；</li></ul><li>同时传递 prop 和 value 参数：设置 attrs 配置信息中的某个属性值；</li></ul><h4 class="section__h4">Returns</h4><dl class="section__dl"><dt class="section__dt">Type：</dt><dd class="section__dd">Any</dd></dl><p>配置信息 attrs 的属性值或者 Outline 对象。</p><pre class="section__pre"><code class="section__code">const outline = new Outline({
   article: '#article',
   title: 'Outline v2.0.0'
})

outline.attrs('title') // -> 'Outline v2.0.0'
outline.attrs('title', '目录') // -> 设置 title 配置信息的值为 '目录'
outline.attrs() // -> 返回完整配置参数 attrs 信息</code></pre></div></section><section class="section"><header class="section__header"><h3 class="section__h3">setStyles(el, styles)</h3></header><div class="section__content"><p>setStyles() 方法用来给 DOM 元素批量添加 CSS 样式。</p><dl class="section__dl"><dt class="section__dt">Category：</dt><dd class="section__dd">Style</dd></dl><h4 class="section__h4">Parameters</h4><h5 class="section__h4">el</h5><dl class="section__dl"><dt class="section__dt">Type：</dt><dd class="section__dd">HTMLElement</dd></dl><p>（必须）主题名称。</p><h5 class="section__h4">styles</h5><dl class="section__dl"><dt class="section__dt">Type：</dt><dd class="section__dd">Object|String</dd></dl><p>（必须）主题名称。</p><pre class="section__pre"><code class="section__code">&lt;ul id="list" class="list"&gt;
    &lt;li class="item active"&gt;Home&lt;/li&gt;
    &lt;li class="item"&gt;Blog&lt;/li&gt;
    &lt;li class="item"&gt;Projects&lt;/li&gt;
    &lt;li class="item"&gt;About&lt;/li&gt;
&lt;/ul&gt;

// 引入 DOM 模块（中的所有工具方法）
import DOM from '@yaohaixiao/dom.js/dom
// 引用 setStyles 单个方法
import setStyles from '@yaohaixiao/dom.js/setStyles'

const $list = DOM.byId('#list')

DOM.setStyle($list, {
  display: 'none',
  'background-color': '#f2f2f2'
))
setStyles($list, {
  'float': 'left',
  'overflow': 'hidden'
})

DOM.getStyle($list, 'background-color') // -> '#f2f2f2'
getStyle($list, 'overflow') // -> 'hidden'</code></pre></div></section><section class="section"><header class="section__header"><h3 class="section__h3">getProperty(prop)</h3></header><div class="section__content"><p>getProperty() 用来获取 CSS 变量（属性）值。</p><dl class="section__dl"><dt class="section__dt">Category：</dt><dd class="section__dd">Style</dd></dl><h4 class="section__h4">Parameters</h4><h5 class="section__h4">prop</h5><dl class="section__dl"><dt class="section__dt">Type：</dt><dd class="section__dd">String</dd></dl><p>（必须）CSS 属性名称。</p><h4 class="section__h4">Returns</h4><dl class="section__dl"><dt class="section__dt">Type：</dt><dd class="section__dd">String</dd></dl><p>返回一个 DOMString ，其中包含请求的 CSS 属性的值。</p><pre class="section__pre"><code class="section__code">&lt;style&gt;
  :root {
    --outline-zIndex: 2000;
    --outline-sticky-height: 100%;
    --outline-chapters-width: 100%;
  }
&lt;/style&gt;

// 引入 DOM 模块（中的所有工具方法）
import DOM from '@yaohaixiao/dom.js/dom
// 引用 getProperty 单个方法
import getProperty from '@yaohaixiao/dom.js/getProperty'

DOM.getProperty('--outline-zIndex') // => '2000'
getProperty('--outline-sticky-height') // => '100%'
getProperty('--outline-chapters-width') // => '100%'</code></pre></div></section><section class="section"><header class="section__header"><h3 class="section__h3">setProperty(prop, value)</h3></header><div class="section__content"><p>setProperty() 用来为一个声明了 CSS 样式的对象设置一个新的值。</p><dl class="section__dl"><dt class="section__dt">Category：</dt><dd class="section__dd">Style</dd></dl><h4 class="section__h4">Parameters</h4><h5 class="section__h4">prop</h5><dl class="section__dl"><dt class="section__dt">Type：</dt><dd class="section__dd">String</dd></dl><p>（必须）CSS 属性名称。</p><h5 class="section__h4">value</h5><dl class="section__dl"><dt class="section__dt">Type：</dt><dd class="section__dd">String</dd></dl><p>（必须）CSS 属性值。</p><pre class="section__pre"><code class="section__code">&lt;style&gt;
  :root {
    --outline - zIndex: 2000;
  }
&lt;/style&gt;

// 引入 DOM 模块（中的所有工具方法）
import DOM from '@yaohaixiao/dom.js/dom
// 引用 setProperty 单个方法
import setProperty from '@yaohaixiao/dom.js/setProperty'

// 设置属性
DOM.setProperty('--outline-sticky-height', '100%')
setProperty('--outline-chapters-width', '100%')

// 获取属性值
DOM.getProperty('--outline-zIndex') // => '2000'
DOM.getProperty('--outline-sticky-height') // => '100%'
DOM.getProperty('--outline-chapters-width') // => '100%'</code></pre></div></section><section class="section"><header class="section__header"><h3 class="section__h3">css(el, attr[, value])</h3></header><div class="section__content"><p>css()方法用来设置或者查询 DOM 元素的 CSS 样式。</p><dl class="section__dl"><dt class="section__dt">Category：</dt><dd class="section__dd">Style</dd></dl><h4 class="section__h4">Parameters</h4><h5 class="section__h4">el</h5><dl class="section__dl"><dt class="section__dt">Type：</dt><dd class="section__dd">String</dd></dl><p>（必须）el 参数指定 DOM 元素。</p><h5 class="section__h4">attr</h5><dl class="section__dl"><dt class="section__dt">Type：</dt><dd class="section__dd">String|Object|Array</dd></dl><p>（必须）指定 CSS 属性名称。</p><h5 class="section__h4">value</h5><dl class="section__dl"><dt class="section__dt">Type：</dt><dd class="section__dd">String</dd></dl><dl class="section__dl"><dt class="section__dt">Default：</dt><dd class="section__dd">true</dd></dl><p>(可选) 要设置的 CSS 属性值。</p><h4 class="section__h4">Returns</h4><dl class="section__dl"><dt class="section__dt">Type：</dt><dd class="section__dd">Object|String</dd></dl><p>返回指定的单个或者 attr 的属性值。</p><pre class="section__pre"><code class="section__code">&lt;ul id="list" class="list"&gt;
    &lt;li class="item active"&gt;Home&lt;/li&gt;
    &lt;li class="item"&gt;Blog&lt;/li&gt;
    &lt;li class="item"&gt;Projects&lt;/li&gt;
    &lt;li class="item"&gt;About&lt;/li&gt;
&lt;/ul&gt;

// 引入 DOM 模块（中的所有工具方法）
import DOM from '@yaohaixiao/dom.js/dom
// 引用 css 单个方法
import css from '@yaohaixiao/dom.js/css'

const $list = DOM.byId('#list')

// 设置单个 CSS 属性值
DOM.css($list, 'display', 'none')
css($list, 'display', 'block')

// 设置多个 CSS 属性值
setStyle($list, {
  'background-color': '#f2f2f2',
  'float': 'left'
})

// 获取单个 CSS 属性值
css($list, 'display') // -> 'block'

// 获取多个 CSS 属性值
css($list, ['background-color', 'float'])
// -> {
//      'background-color': '#f2f2f2',
//      'float': 'left'
//    }</code></pre></div></section><section class="section"><header class="section__header"><h3 class="section__h3">prop(prop[, value])</h3></header><div class="section__content"><p>$emit()方法用来获取 CSS 样式的属性或者为一个声明了 CSS 样式的对象设置一个新的值。</p><dl class="section__dl"><dt class="section__dt">Category：</dt><dd class="section__dd">Style</dd></dl><h4 class="section__h4">Parameters</h4><h5 class="section__h4">prop</h5><dl class="section__dl"><dt class="section__dt">Type：</dt><dd class="section__dd">String</dd></dl><p>（必须）CSS 属性名称。</p><h5 class="section__h4">value</h5><dl class="section__dl"><dt class="section__dt">Type：</dt><dd class="section__dd">String</dd></dl><p>（必须）CSS 属性值。</p><pre class="section__pre"><code class="section__code">&lt;style&gt;
  :root {
    --outline - zIndex: 2000;
  }
&lt;/style&gt;

// 引入 DOM 模块（中的所有工具方法）
import DOM from '@yaohaixiao/dom.js/dom
// 引用 prop 单个方法
import prop from '@yaohaixiao/dom.js/prop'

// 设置属性
DOM.prop('--outline-sticky-height', '100%')
prop('--outline-chapters-width', '100%')

// 获取属性值
prop('--outline-zIndex') // => '2000'
prop('--outline-sticky-height') // => '100%'
prop('--outline-chapters-width') // => '100%'</code></pre></div></section></section><section class="section"><header class="section__header"><h2 class="section__title">Node Type Detection</h2></header><div class="section__content"><p>dom.js 提供以下方法用于判断 DOM 元素的类型。</p></div><section class="section"><header class="section__header"><h3 class="section__h3">isCollection(el)</h3></header><div class="section__content"><p>isCollection() 方法用来检测测试数据是否为 HTMLNodeList (元素集合)类型。</p><dl class="section__dl"><dt class="section__dt">Category：</dt><dd class="section__dd">Attributes</dd></dl><h4 class="section__h4">Parameters</h4><h5 class="section__h4">el</h5><dl class="section__dl"><dt class="section__dt">Type：</dt><dd class="section__dd">Any</dd></dl><p>（必须）el 参数指定待检测的 DOM 元素。</p><h4 class="section__h4">Returns</h4><dl class="section__dl"><dt class="section__dt">Type：</dt><dd class="section__dd">Boolean。</dd></dl><p>true - 表示检测数据是 HTMLNodeList (元素集合)类型，false 则表示不是。</p><pre class="section__pre"><code class="section__code">// 引入 DOM 模块（中的所有工具方法）
import DOM from '@yaohaixiao/dom.js/dom'
// 或者单独引用 isCollection() 方法
import isCollection from '@yaohaixiao/types.js/isCollection'

const $list = document.getElementById('list')
const $div = document.createElement('div')
const $text = document.createTextNode('text')
const $items = document.querySelectorAll('.item')
const $fragment = document.createDocumentFragment()

DOM.isElement($list) // -> true
DOM.isCollection($list) // -> false

DOM.isElement($div) // -> true
DOM.isCollection($div) // -> false

DOM.isElement($text) // -> false
DOM.isCollection($text) // -> false

DOM.isElement($items) // -> false
isCollection($items) // -> true

DOM.isElement($fragment) // -> false
isCollection($fragment) // -> false</code></pre></div></section><section class="section"><header class="section__header"><h3 class="section__h3">isDOM(el)</h3></header><div class="section__content"><p>isDOM() 方法用来检测测试数据是否为 DOM 类型数据：DOM 节点，TextNode，NodeList 和 DocumentFragment）。</p><dl class="section__dl"><dt class="section__dt">Category：</dt><dd class="section__dd">Attributes</dd></dl><h4 class="section__h4">Parameters</h4><h5 class="section__h4">el</h5><dl class="section__dl"><dt class="section__dt">Type：</dt><dd class="section__dd">Object</dd></dl><p>（必须）el 参数指定待检测的 DOM 元素。</p><h4 class="section__h4">Returns</h4><dl class="section__dl"><dt class="section__dt">Type：</dt><dd class="section__dd">Boolean。</dd></dl><p>true - 表示检测数据是 DOM 类型数据，false 则表示不是。</p><pre class="section__pre"><code class="section__code">// 引入 DOM 模块（中的所有工具方法）
import DOM from '@yaohaixiao/dom.js/dom'
// 或者单独引用 isTextNode() 方法
import isDOM from '@yaohaixiao/dom.js/isDOM'

const $list = document.getElementById('list')
const $fragment = document.createDocumentFragment()
const $items = document.querySelectorAll('.item')
const $text = document.createTextNode('text')

DOM.isDOM($list) // -> true
DOM.isDOM($fragment) // -> true
DOM.isElement($items) // -> false
isDOM($items) // -> true
isText($text) // -> true
isDOM($text) // -> true</code></pre></div></section><section class="section"><header class="section__header"><h3 class="section__h3">isElement(el)</h3></header><div class="section__content"><p>isElement() 方法用来检测测试数据是否为 HTMLElement (元素节点)类型。</p><dl class="section__dl"><dt class="section__dt">Category：</dt><dd class="section__dd">Attributes</dd></dl><dl class="section__dl"><dt class="section__dt">Category：</dt><dd class="section__dd">Lang</dd></dl><h4 class="section__h4">Parameters</h4><h5 class="section__h4">el</h5><dl class="section__dl"><dt class="section__dt">Type：</dt><dd class="section__dd">Any</dd></dl><p>（必须）el 参数指定待检测的 DOM 元素。</p><h4 class="section__h4">Returns</h4><dl class="section__dl"><dt class="section__dt">Type：</dt><dd class="section__dd">Boolean。</dd></dl><p>true - 表示检测数据是 HTMLElement (元素节点)类型，false 则表示不是。</p><pre class="section__pre"><code class="section__code">// 引入 DOM 模块（中的所有工具方法）
import DOM from '@yaohaixiao/dom.js/dom'
// 或者单独引用 isElement() 方法
import isElement from '@yaohaixiao/dom.js/isElement'

const $list = document.getElementById('list')
const $div = document.createElement('div')
const $text = document.createTextNode('text')
const $items = document.querySelectorAll('.item')
const $fragment = document.createDocumentFragment()

DOM.isElement($list) // -> true
DOM.isElement($div) // -> true
DOM.isElement($text) // -> false
isElement($items) // -> false
isElement($fragment) // -> false</code></pre></div></section><section class="section"><header class="section__header"><h3 class="section__h3">isFragment(el)</h3></header><div class="section__content"><p>isFragment() 方法用来检测测试数据是否为 DocumentFragment 文档碎片。</p><dl class="section__dl"><dt class="section__dt">Category：</dt><dd class="section__dd">Attributes</dd></dl><h4 class="section__h4">Parameters</h4><h5 class="section__h4">el</h5><dl class="section__dl"><dt class="section__dt">Type：</dt><dd class="section__dd">Any</dd></dl><p>（必须）val 待检测的数据。</p><h4 class="section__h4">Returns</h4><dl class="section__dl"><dt class="section__dt">Type：</dt><dd class="section__dd">Boolean。</dd></dl><p>true - 表示检测数据是 DocumentFragment 文档碎片，false 则表示不是。</p><pre class="section__pre"><code class="section__code">// 引入 DOM 模块（中的所有工具方法）
import DOM from '@yaohaixiao/dom.js/dom'
// 或者单独引用 isFragment() 方法
import isFragment from '@yaohaixiao/dom.js/isFragment'

const $list = document.getElementById('list')
const $div = document.createElement('div')
const $text = document.createTextNode('text')
const $items = document.querySelectorAll('.item')
const $fragment = document.createDocumentFragment()

DOM.isElement($list) // -> true
DOM.isFragment($list) // -> false

DOM.isElement($div) // -> true
DOM.isFragment($div) // -> false

DOM.isElement($text) // -> false
DOM.isFragment($text) // -> false

DOM.isElement($items) // -> false
isFragment($items) // -> false

DOM.isElement($fragment) // -> false
isFragment($fragment) // -> true</code></pre></div></section><section class="section"><header class="section__header"><h3 class="section__h3">isText(el)</h3></header><div class="section__content"><p>isText() 方法用来检测测试数据是否为 HTMLTextNode (文本节点)类型。</p><dl class="section__dl"><dt class="section__dt">Category：</dt><dd class="section__dd">Attributes</dd></dl><h4 class="section__h4">Parameters</h4><h5 class="section__h4">el</h5><dl class="section__dl"><dt class="section__dt">Type：</dt><dd class="section__dd">Any</dd></dl><p>（必须）el 参数指定待检测的 DOM 元素。</p><h4 class="section__h4">Returns</h4><dl class="section__dl"><dt class="section__dt">Type：</dt><dd class="section__dd">Boolean。</dd></dl><p>true - 表示检测数据是 HTMLTextNode (文本节点)类型，false 则表示不是。</p><pre class="section__pre"><code class="section__code">// 引入 DOM 模块（中的所有工具方法）
import DOM from '@yaohaixiao/dom.js/dom'
// 或者单独引用 isText() 方法
import isText from '@yaohaixiao/dom.js/isText'

const $list = document.getElementById('list')
const $div = document.createElement('div')
const $fragment = document.createDocumentFragment()
const $items = document.querySelectorAll('.item')
const $text = document.createTextNode('text')

DOM.isElement($list) // -> true
DOM.isText($list) // -> false

DOM.isElement($div) // -> true
DOM.isText($div) // -> false

DOM.isFragment($fragment) // -> true
DOM.isText($fragment) // -> false

DOM.isCollection($items) // -> true
DOM($items) // -> false

DOM.isElement($text) // -> false
isText($text) // -> true</code></pre></div></section></section></article><footer class="main__footer" id="footer"><p>Copyright &copy; 2023 <a href="https://github.com/yaohaixiao">Robert Yao</a>, all right reserved.</p><p>Code licensed under&nbsp;<a href="http://opensource.org/licenses/mit-license.html">MIT License</a></p><p>Documentation licensed under&nbsp;
<a href="http://creativecommons.org/licenses/by/3.0/">CC BY 3.0</a></p><p><a href="https://github.com/yaohaixiao/dom.js">View on GitHub</a> ·
<a href="https://github.com/yaohaixiao/dom.js/issues">Issues</a></p></footer></main></div><script src="js/dom.min.js" type="text/javascript"></script><script src="js/docs.min.js" type="text/javascript"></script></body></html>